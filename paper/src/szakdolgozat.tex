% LaTeX mintafájl szakdolgozat és diplomamunkáknak az
% SZTE Informatikai Tanszékcsoportja által megkövetelt
% formai követelményeinek megvalósításához
% Modosítva: 2011.04.28 Nemeth L. Zoltan
% A fájl használatához szükséges a magyar.ldf 2005/05/12 v1.5-ös vagy későbbi verziója
% ez letölthető a http://www.math.bme.hu/latex/ weblapról, a magyar nyelvű szedéshez
% Hasznos információk, linekek, LaTeX leírások a www.latex.lap.hu weboldalon vannak.
%

\documentclass[12pt]{report}

%Magyar nyelvi támogatás (Babel 3.7 vagy későbbi kell!)
\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}

%Az ékezetes betűk használatához:
\usepackage{t1enc}% ékezetes szavak automatikus elválasztásához
\usepackage[utf8]{inputenc}% ékezetes szavak beviteléhez

% A formai kovetelmenyekben megkövetelt Times betűtípus használata:
\usepackage{times}

%Az AMS csomagjai
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

%A fejléc láblécek kialakításához:
\usepackage{fancyhdr}

%Természetesen további csomagok is használhatók,
%például ábrák beillesztéséhez a graphix és a psfrag,
%ha nincs rájuk szükség természetesen kihagyhatók.
\usepackage{graphicx}
\usepackage{psfrag}
\usepackage{stackengine,trimclip}

\usepackage{setspace}

\usepackage{hyperref}
\hypersetup{
    pdfauthor={LEDÁN Szilárd},
    pdftitle={2D alakzatrajzolás OpenGL~ES~2.0 alapokon},
    pdfsubject={BSc szakdolgozat},
    pdfkeywords={2D graphics, path, Canvas 2d Context, OpenGL ES 2.0},
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{cite}

\usepackage{enumerate}
\usepackage{enumitem}

\setlist[enumerate]{%
    topsep=1ex,%
    itemsep=-1ex,%
    partopsep=1ex,%
    parsep=1ex,%
}
\setlist[itemize]{%
    noitemsep,%
    topsep=1ex,%
}
\setlist[description]{%
    noitemsep,%
}

% Színek
\usepackage{color}
\definecolor{myCommentColorGreen}{RGB}{0,128,0}
\definecolor{myLineNumberGray}{RGB}{128,128,128}

% Forráskódhoz
\usepackage{listings}
\usepackage{lstautogobble}
\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else,%
            finally, for, function, if, in, instanceof, new, return, switch,%
            this, throw, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}
\lstset{ %
    %backgroundcolor=\color{white},   % choose the background color; you must add  \usepackage{color} or \usepackage{xcolor}
    basicstyle=\scriptsize, %\footnotesize,         % the size of the fonts that are used for    the code
    %breakatwhitespace=false,         % sets if automatic breaks should only      happen at whitespace
    breaklines=true,                  % sets automatic line breaking
    captionpos=b,                    % sets the caption-position to          bottom
    commentstyle=\color{myCommentColorGreen},    % comment style
    %deletekeywords={...},            % if you want to delete keywords              from the given language
    %escapeinside={\%*}{*)},          % if you want to add LaTeX                within your code
    %extendedchars=true,              % lets you use non-ASCII                  characters; for 8-bits encodings only, does not work with                  UTF-8
    frame=leftline,                   % adds a frame around the                    code
    %keepspaces=true,                 % keeps spaces in text,                      useful for keeping indentation of code (possibly needs                      columns=flexible)
    inputpath=../../../,
    keywordstyle=\color{blue},        % keyword style
    language=C++,                     % the language of                          the code
    literate=%
        {á}{{\'a}}1
        {é}{{\'e}}1
        {í}{{\'i}}1
        {ó}{{\'o}}1
        {ö}{{\"o}}1
        {ő}{{\H{o}}}1
        {ú}{{\'u}}1
        {ü}{{\"u}}1
        {ű}{{\H{u}}}1
        {Á}{{\'A}}1
        {É}{{\'E}}1
        {Í}{{\'I}}1
        {Ó}{{\'O}}1
        {Ö}{{\"O}}1
        {Ő}{{\H{O}}}1
        {Ú}{{\'U}}1
        {Ü}{{\"U}}1
        {Ű}{{\H{U}}}1,
    %morekeywords={*,...},            % if you want to                            add more keywords to the set
    numberfirstline=true,
    numbers=left,                     % where to put                              the line-numbers; possible values are (none, left, right)
    numbersep=10pt,                   % how far theline-numbers are from the code
    numberstyle=\tiny\color{myLineNumberGray}, % the stylethat is used for the line-numbers
    %name=\thelstnumber,              %
    %rulecolor=\color{black},         % if notset, the frame-color may be changed online-breaks within not-black text (e.g.comments (green here))
    showspaces=false,                % showspaces everywhere adding particularunderscores; it overrides'showstringspaces'
    showstringspaces=false,          % underline spaces within strings only
    showtabs=false,                  % show tabs within strings addingparticular underscores
    %stepnumber=2,                    % the step between two line-numbers.If it's 1, each line will benumbered
    %stringstyle=\color{mymauve},     % string literal style
    tabsize=4,                        % sets default tabsize to 2    spaces
    %title=\lstname                   % show the filename of     files included with     \lstinputlisting; also try     caption instead of title
}

% Kép mellett folyó íráshoz
\usepackage{wrapfig}

\usepackage[labelfont=it,justification=centering]{caption}

\usepackage{epigraph}
%\epigraphfontsize{\small\itshape}

%Tételszerű környezetek definiálhatók, ezek most fejezetenként együtt számozódnak, pl.
\newtheorem{tét}{Tétel}[chapter]
\newtheorem{defi}[tét]{Definíció}
\newtheorem{lemma}[tét]{Lemma}
\newtheorem{áll}[tét]{Állítás}
\newtheorem{köv}[tét]{Következmény}

%Ha a megjegyzések és a példak szövegét nem akarjuk dőlten szedni, akkor
%az alábbi parancs után kell őket definiální:
\theoremstyle{definition}
\newtheorem{megj}[tét]{Megjegyzés}
\newtheorem{pld}[tét]{Példa}

%%% Saját parancsok %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Az angol kifejezések kiemelése.
\newcommand{\inenglish}[1]{\textsl{#1}}
\newcommand{\inenglishfn}[1]{\footnotesize{\inenglish{#1}}}

%%% A függvények a szövegben.
\newcommand{\func}[1]{{\textsl{#1}}}

%%% Globális beállítás a WRAPFIGUREnak.
% A WRAPFIGUREnak adhatjuk meg az egész dolgozatban, hogy milyen globális
% stratégia szerint helyezze el a képeket: r - right, o - outside, l - left,
% i - inside, stb. A magyar makrónév melletti érv a lehetséges ütközések
% elkerülése. Az alapbeállítás az 'r', a szakdolgozat egyoldalas
% nyomtatása miatt, ha azonban az aktuális helyzet megkívánja, a makró
% használatát mellőzzük.
\newcommand{\melyikoldalra}{r}
%\newcommand{\melyikoldalra}{o} % az oldal külső felére

%%% Az INCLUDEGRAPHICS kivágások globális eltolása.
% A néhány sorral lentebbi \setpdfoffset{0pt}{0pt} átállításával a
% a kivágást globálisan eltolhatjuk.
\makeatletter
\define@key{Gin}{xviewport}[]{%
  \begingroup\edef\x{%
    \endgroup\noexpand\setkeys{Gin}{viewport=\x@viewport}%
  }\x
}
\newlength{\Xoffset}
\newlength{\Yoffset}
\newcommand*{\setpdfoffset}[2]{%
  \setlength{\Xoffset}{#1}%
  \setlength{\Yoffset}{#2}%
}
\newcommand*{\setviewport}[4]{%
  \def\x@viewport{%
    {\the\dimexpr#1-\Xoffset}
    {\the\dimexpr#2-\Yoffset}
    {\the\dimexpr#3-\Xoffset}
    {\the\dimexpr#4-\Yoffset}%
  }%
}
\makeatother
% Paraméterek:
%   #1 - llx, alsó bal sarok x érték,
%   #2 - lly, alsó bal sarok y érték,
%   #3 - urx, felső jobb sarok x érték,
%   #4 - ury, felső jobb sarok y érték,
%   #5 - szabad lokális beállítások,
%   #6 - a beszúrandó kép.
\newcommand{\includegraphicskivagas}[6]{
    \setpdfoffset{0pt}{0pt}
    \setviewport{#1}{#2}{#3}{#4}
    \includegraphics[xviewport,clip,#5]{#6}
}
% Az 'img/built/dataflow_eps' képre specializált INCLUDEGRAPHICSKIVAGAS.
\newcommand{\includedataflowkivagas}[5]{
    \includegraphicskivagas{#1}{#2}{#3}{#4}{scale=0.6,#5}
    {img/built/dataflow_eps}
}

%\hyphenation{sza-bály el-kü-lö-ní-tett}

%%% Saját parancsok %%% VÉGE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Margók:
\hoffset -1in
\voffset -1in
\oddsidemargin 35mm
\textwidth 150mm
\topmargin 15mm
\headheight 10mm
\headsep 5mm
\textheight 237mm

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Címlap                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %A FEJEZETEK KEZDŐOLDALAINAK FEJ ÉS LÁBLÉCE:
    %a plain oldalstílust kell átdefiniálni, hogy ott ne legyen fejléc:
    \fancypagestyle{plain}{%
    %ez mindent töröl:
    \fancyhf{}
    % a láblécbe jobboldalra kerüljön az oldalszám:
    \fancyhead[R]{\thepage}
    %elválasztó vonal sem kell:
    \renewcommand{\headrulewidth}{0pt}
    }

    %A TÖBBI OLDAL FEJ ÉS LÁBLÉCE:
    \pagestyle{fancy}
    \fancyhf{}
    \fancyhead[L]{\rightmark}
    \fancyhead[R]{\thepage}


    %A címoldalra se fej- se lábléc nem kell:
    \thispagestyle{empty}

    \begin{center}
    \vspace*{1cm}
    {\Large\bf Szegedi Tudományegyetem}

    \vspace{0.5cm}

    {\Large\bf Informatikai Tanszékcsoport}

    \vspace*{3.8cm}

    % Tíz sorral fentebb is át kell írni!!!
    {\LARGE\bf 2D alakzatrajzolás OpenGL~ES~2.0 alapokon}


    \vspace*{3.6cm}

    %{\Large Diplomamunka}
    {\Large Szakdolgozat}

    \vspace*{4cm}

    %Értelemszerűen megváltoztatandó:
    {\large
    \begin{tabular}{c@{\hspace{4cm}}c}
    \emph{Készítette:}     &\emph{Témavezető:}\\
    \bf{Ledán Szilárd}  &\bf{Dr. Kiss Ákos}\\
    informatika szakos     &egyetemi adjunktus\\
    hallgató &
    \end{tabular}
    }

    \vspace*{2.3cm}

    {\Large
    Szeged
    \\
    \vspace{2mm}
    2018
    }
    \end{center}


    % 1.5-ös sorköz:
    % ezt javasolják:  \linespread{1.25}
    % és ez bevált, de ehhez kellett a \usepackage{setspace} csomag betöltése.
    \onehalfspacing


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Mottó                                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \clearpage
    \thispagestyle{empty}
    {
    \setlength\epigraphrule{0pt}
    \linespread{1.0}\epigraph{\small\emph{,,A világ csak híd, menj át rajta,
    de ne építs rajta házat.''}}{\small(IHS)}
    }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Tartalomjegyzék                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Feladatkiírás                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    %A \chapter* parancs nem ad a fejezetnek sorszámot
    \chapter*{Feladatkiírás}
    %A tartalomjegyzékben mégis szerepeltetni kell, mint szakasz(section) szerepeljen:
    \addcontentsline{toc}{section}{Feladatkiírás}

A témavezető által megfogalmazott feladatkiírás. Önálló oldalon szerepel.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Tartalmi összefoglaló                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter*{Tartalmi összefoglaló}
    \addcontentsline{toc}{section}{Tartalmi összefoglaló}

%A tartalmi összefoglalónak tartalmaznia kell (rövid, legfeljebb egy oldalas, összefüggő megfogalmazásban)
%a következőket: a téma megnevezése, a megadott feladat megfogalmazása - a feladatkiíráshoz viszonyítva-,
%a megoldási mód, az alkalmazott eszközök, módszerek, az elért eredmények, kulcsszavak (4-6 darab).

%Az összefoglaló nyelvének meg kell egyeznie a dolgozat nyelvével. Ha a dolgozat idegen nyelven készül,
%magyar nyelvű tartalmi összefoglaló készítése is kötelező (külön lapon), melynek terjedelmét a TVSZ szabályozza.

    \subsubsection*{A téma megnevezése}

A \emph{World Wide Web Consortium} (W3C) által \emph{Canvas 2D Context} néven
2015-ben elfogadott ajánlás \emph{path} részének megvalósítása
\emph{OpenGL~ES~2.0} alapokon.

    \subsubsection*{A megadott feladat megfogalmazása}

Az előbb említett \emph{Canvas 2D Context} egy grafikus interfész. Ez az
interfész több grafikus függvényt definiál. Jelen dolgozat témája ezek közül az
úgynevezett \emph{path} részének leprogramozása úgy, hogy a lehető legtöbb
feladatot a grafikus processzor (\textit{GPU}) lássa el.

    \subsubsection*{A megoldásmód}

Több megoldás közül mi az alakzatok trapézokra bontását választottuk. Minden
trapéz felbontható további két háromszögre, amely megkötésre a OpenGL~ES~2.0
grafikus meghajtó miatt van szükség.

    \subsubsection*{Alkalmazott eszközök, módszerek}

Az API \emph{C++11} programozási nyelven készült, használva a következő
eszközöket, technológiákat: \emph{gcc}, \textit{OpenGL~ES~2.0} függvénykönyvtár.

    \subsubsection*{Elért eredmények}

    \subsubsection*{Kulcsszavak}

 Canvas~2D~Context, OpenGL~ES~2.0, számítógépes grafika (\inenglish{computer
 graphics}), szabad alakzat (\inenglish{path}), trapéz tesszelláció
 (\inenglish{trapezoid tessellation})


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Bevezetés                                                      %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter*{Bevezetés}
    \label{Bevezetés}
    \addcontentsline{toc}{section}{Bevezetés}

A környezetünkben található számítástechnikai eszközök legtöbbjének van
grafikus kijelzője, és ezen eszközök mindegyike használ valamilyen
megjelenítő~\footnote{A számítógépes grafikában egy modell megjelenítését végző
folyamatot \emph{renderelés}nek (\inenglishfn{rendering}), a renderelést végző
programrészt pedig \emph{motor}nak (\inenglishfn{engine}) hívnak} (a
továbbiakban renderelő) függvénykönyvtárat. Ilyen például a Skia, a Cairo, az
OpenGL, és ilyen kíván lenni a \emph{Gepard} is. A cél egy \emph{C++11}-es
nyelven írt és több (\mbox{OpenGL~ES~2.0 \cite{Munshi:2008:OEP:1481069}},
Vulkan) grafikus renderelő motort támogató függvénykönyvtár.

A tervek szerint idővel a Gepard több interfésszel is rendelkezik. Így alkot
majd egy komplex grafikus alkalmazásprogramozási felületet
(\inenglish{Application Programming Interface}, a továbbiakban API). Az elsőnek
választott ilyen ismertebb interfész amit támogatni kíván az a \emph{W3C} által
készített \emph{Canvas 2D Context}~\cite{Cabanier:14:HCC} előírás.

A \emph{Canvas 2D Context} (a továbbiakban \emph{Canvas}) előírás 2015-ös
kiadása több elkülönített részből állítja össze az API-t. Ezen részek egyike az
úgynevezett \emph{Path}. Az említett 2015-ös előírás az 5., 8. és 11.
fejezetekben részletezi a Path-szal szembeni elvárásokat. A Path maga a
definiált grafikus alakzatokhoz képest bonyolultabbak leírását biztosító
eszköz. A Háttér (\ref{Háttér}.) fejezetben részletesebben kifejtjük a path-t
építő eszköz lehetőségeit és szabályait. Itt most csak annyiban kell kitérjünk
rá, hogy alapvetően két nagyobb részből áll. A \emph{körvonalból}
(\inenglish{stroke}) és a \emph{kitöltésből} (\inenglish{fill}).

Jelen dolgozat az említett \emph{Path} rész megvalósítását kívánja bemutatni.
Azt, hogy milyen szabályoknak kellett megfelelni, illetve milyen lehetőségeket
biztosított a választott OpenGL~ES~2.0 (a továbbiakban GLES2) szabvány, és azt,
hogy hogyan alkot köztes réteget ezek között a Gepard Path-t rajzoló, renderelő
része.

Első körben nem volt cél a ,,leggyorsabban futó'' és ,,legkisebb méretű''
Path-t rajzoló API elkészítése. Célunk egy lehetséges megvalósítás megtalálása,
és ez alapján egy olyan eszköz megalkotása volt, amely képes a választott
előírás (Canvas) elvárásait teljesíteni.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Háttér                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter{Háttér}
    \label{Háttér}

Ez a fejezet mutatja be azokat a technológiákat és kihívásokat, amelyek keretet
szabtak a téma megvalósításának. Szót kell ejteni magáról a Canvas 2D Context
API\footnote{Az \emph{alkalmazásprogramozási felület/interfész}
(\inenglish{Application Programming Interface}) kifejezésre a továbbiakban mint
\emph{API} hivatkozunk.} előírásról, a GLES2 szabvány nyújtotta lehetőségekről,
azokról a matematikai módszerekről, amelyek biztosítják számunkra, hogy
tetszőlegesen bonyolult -- szerencsénkre zárt -- alakzatok kitöltését helyesen
elvégezhessük. Össze kellett kapcsolni a választott GLES2 szabta
megkötést~\footnote { Az OpenGL 2.0 legfeljebb háromszögeket rajzol. } a Canvas
Path~API elvárásaival~\footnote { Elvárás a tetszőleges számú körcikk, szakasz
és Bézier görbe alkotta -- akár önmetsző -- alakzat mérethelyes megjelenítése.
}. Ehhez több lépésbeli megközelítést (\inenglish{approximation}) alkalmaztunk.
Ezekről a lépésekről is érdemes lesz beszélni.

    \section[A Canvas 2D Context előírás]{A W3C Canvas 2D Context előírás}
    \label{A Canvas előírás}

A Canvas API egy közel tíz éves, kiforrott technológia\footnote {A W3C HTML5
szabvány, és az azon belüli Canvas \emph{első} vázlata 2008-as:\\
\footnotesize{ \url{https://www.w3.org/TR/2008/WD-html5-20080122/\#the-2d}} }.
Az előírás leír egy felbontásfüggő rajzolóvásznat, amelyet jellemzően
\emph{Canvas}-nek neveznek. A Canvas definíció szerint nem más mint egy adott
\emph{szélességgel} és \emph{magassággal} meghatározott terület, ahova
különböző alakzatokat, képeket, szövegeket és egyéb nem dinamikus grafikai
elemeket rakhatunk fel. Az elemeket függvények segítségével rajzolhatjuk a
vászonra, vagy pedig a Canvas-hez tartozó \emph{context} gyűjti, és bizonyos
parancsok (pl.~\emph{fill}) esetén az addig összegyűjtött elemeket kirajzolja a
megadott sorrendben. Végül mindig egy \emph{kép} (\inenglish{image}) vagy még
pontosabban egy \emph{bit-térkép} (\inenglish{bitmap}) készül.

Az előíráson belül definiált Path API rész amúgy egy régebbi, elterjedt
alakzatszerkesztő eljáráson alapul. Az eljárás lényege, hogy bizonyos alap
eszközökkel definiálunk egy bonyolultabb formát. Ezt a folyamatot hívjuk
alakzat építésnek (\inenglish{shape/path building}). Az építés után különböző
parancsokkal rajzolhatjuk ki a definiált alakzatot, akár kitöltve
(\emph{fill}), akár körvonalként (\emph{stroke}), de lehetőségünk van az adott
alakzattal kivágni (\emph{clip}) is a rajzvásznon már meglévő képből.

A Canvas előír néhány megkötést. Ezekről látni fogjuk, hogy természetes
korlátok. Hiszen józan ésszel felfogható, hogy egy egyenes szakaszból definiált
alakzatra értelmetlen a \emph{kitöltés} (\func{fill}) parancsot meghívni.
Hasonlóan nem mond semmit a nulla vastagságú vonal a \emph{körvonal rajzolása}
(\func{stroke}) parancs esetén. Érdekes belegondolni abba is, hogy mi legyen
egy definiált alakzat sorsa, ha már kirajzoltuk. Vessük el, vagy tartsuk meg. A
szabvány megalkotói -- amúgy programozási szempontból jól indokolható módon --
a megtartás mellett döntöttek. Így viszont az a fontos megkötés is megjelent,
hogy mindig egyértelműen jelezni kell, ha új alakzatot akarunk definiálni.

A W3C-féle Canvas felfogható egy állapotgépnek. Ami ebben a esetben azt
jelenti, hogy bizonyos beállítások (kitöltőszín, betűméret, vonalvastagság,
transzformációk stb.) érvényben maradnak mindaddig, amíg meg nem változtatjuk
azokat. Ezt már az előbb említett felépített vonal esetén is érezhettük. Mint
később látni fogjuk, ez erősen megköti a kezünket, hogy milyen rajzoló program
is lehet a Gepard. Persze a Gepard idővel kibővülhet további
funkcionalitásokkal (pl. \emph{flush}, \emph{finish} stb.), amik egy sokkal
kötetlenebb rajzoló eszközhöz vezethetnek.

Térjünk vissza egy kis példa erejéig a Path építéshez. Feltételezzük, hogy
kedvünkre beállítottuk a rajzolás színét, a méreteket stb. Valamint minden
szükséges módon felkészítettük a vásznunkat arra, hogy felvigyük rá a kívánt
alakzatot. Ez most legyen egy háromszög, mint az egyik legegyszerűbb, ám a
szabványban külön nem definiált forma, ellentétben a téglalappal (\emph{rect},
\emph{fillRect}, \emph{strokeRect}).

  \begin{figure}[!htb]
    \hspace{0.1\textwidth}
    \minipage{0.5\textwidth}
      \centering
      \begin{lstlisting}[language=JavaScript, autogobble=true]
        var cv = document.getElementById("Canvas");
        var ctx = cv.getContext("2d");
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(6, 9);
        ctx.lineTo(0, 3);
        ctx.closePath();  // top line
        ctx.fill();  // last two columns
        ctx.stroke();  // first two columns
      \end{lstlisting}
    \endminipage
    \hfill
    \minipage{0.5\textwidth}
      \includegraphics[width=.5\textwidth]{img/built/triangle}
    \endminipage
    \caption{\label{triangles-code-and-image} Bezárt és nyitva hagyott
    alakzatok körvonalai és kitöltései }
  \end{figure}

A fenti ábrán (\emph{\ref{triangles-code-and-image}}) látható egy kis példakód,
illetve ennek hat különböző eredménye. Az első sorban olyan alakzatokat látunk,
ahol a \func{closePath} parancsot meghívtuk (hármoszög), a másodikban pedig nem
(V alak). Az első oszlopban a \func{fill}-t, a harmadikban pedig a
\func{stroke}-ot nem hívtuk meg. Az előírás ugyanakkor rendelkezik arról, hogy
minden Path zárt alakzat kell legyen, így mindig kitölthető is. Ezért lett a
második sor utolsó két V-nek definiált alakzata mégis kitöltött háromszög.
Nézzük meg, hogy milyen konkrét eszközöket biztosít az előírás.

Ebben a fejezetben nem térünk ki részletesen a teljes előírásra. A legfontosabb
rész a dolgozatunk témája a Path. Ugyanakkor a munkához szorosan kapcsolódott a
környezet megvalósítása is. Ezért érintőlegesen beszélnünk kell a rajzolás
kontextusáról (\inenglish{drawing context}), a színek és vonaltulajdonságok
beállításáról, valamint a transzformációkról. Ezek után térünk rá az előírás
Path-t definiáló részére.

A rajzolás környezete, vagyis a \emph{context} tartalmazza, hogy milyen
színekkel fogunk rajzolni, milyen betűtípussal és mérettel, de ez tartalmazza
az aktuális transzformációt és itt van elméletileg letárolva az aktuálisan
felépített alakzat (\inenglish{path}) is. A context-nek mindig van egy aktuális
állapota (\inenglish{state}). A Canvas rendelkezik arról, hogy az aktuális
állapotot egy verembe elmenthessük és visszaállíthassuk. Ez a tulajdonsága a
vászonnak megkönnyíti a transzformációk alkalmazását egy-egy alakzatra, vagy
képre, esetleg szövegre. Ugyanakkor az állapot elmentése nem érinti az épített
alakzatot. Vagyis nincs hatással a path-ra. A context mindig egy path-t
tartalmaz, határoz meg. Ha például egy ilyen alakzatot több különböző színnel
és helyen szeretnénk a vászonra rajzolni, de nem akarjuk elveszíteni az
aktuális állapot szín- és koordináta-beállításait, akkor egy mentés után
könnyedén módosíthatjuk az attribútumokat, és tolhatjuk el az alakzatot. Majd a
kirajzolások után visszaállíthatjuk az elmentett állapotot.

A dolgozatunkat két színbeállítás érinti. Az egyik az alakzat kitöltésekor
használt \func{fillStyle} attribútum. A másik az alakzat körvonalának színét
meghatározó \func{strokeStyle} attribútum. Ezek az attribútumok nem csak színek
lehetnek, hanem például leírhatnak egy gradiens színezést is. Illetve nem csak
néhány névvel előre definiált színt (\func{red}, \func{green}, \func{blue}
stb.) adhatunk meg, hanem különböző színterekből csatornánként saját színt is
beállíthatunk. Ilyen például az \emph{RGBA} vagy az \emph{HSV}\footnote{Az
említett színterekhez tartozó hívások: \func{rgba(red, green, blue, alpha)},
\func{hsv(hue, saturation, value)}.} színtér. Sőt, lehetőségünk van használni a
webes környezetekben megszokott úgynevezett hexa-kódokat. Ekkor az RGB
színtérből választhatunk, és kétféle mintát használhatunk: a hosszabb
\func{\#rrggbb}-t és a rövidebb \func{\#rgb}-t. A két attribútum viselkedését a
CSS ajánlás\footnote{A W3C CSS Color Module Level 3:\footnotesize{
\url{https://www.w3.org/TR/css-color-3/}}.} írja le. A beállítást szöveges
(\func{string}) formában kell megadni, amit aztán értelmezni kell, és aszerint
megadni az értékeket. Később részletesen lesz szó arról, hogy milyen módon
oldottuk meg a hasonló viselkedést C++-os környezetben.

A színekhez hasonlóan az alakzat körvonalának tulajdonságát leíró
attribútumokat (pl. \func{lineWidth}) is szöveg formájában kell megadni. Itt
viszont van egy kis játéktér, mert az ajánlás ugyan szöveget várna, de mivel
itt számértékekről van szó, ezért elfogadhatunk majd ténylegesen szám típust
is. Erről is lesz szó az alakzatépítés működését leíró fejezetben.

A Canvas állapotaihoz mindig tartozik egy affin-transzformációt leíró hatelemű
mátrix. Ezt a mátrixot módosíthatjuk a \func{scale(x, y)}, a
\func{rotate(angle)}, a \func{translate(x, y)},  a \func{transform(a, b, c, d,
e, f)} és a \func{setTransform(a, b, c, d, e, f)} függvényekkel. Az utolsó két
függvény esetén a változók a homogén transzformációs mátrix módosítható
értékeit reprezentálják\footnote{Cabanier et al.: \emph{{HTML} Canvas {2D}
Context}, 2015, W3C\\ \footnotesize{ \url{https://www.w3.org/TR/2dcontext/}},
6. fejezet.}: \[\begin{pmatrix}a & c & e \\ b & d & f \\ 0 & 0 & 1 \\
\end{pmatrix}\]

Végül nézzük a \emph{Path API} részt. A Canvas-ben a Path API két részből áll.
Egyrészt a Path-t építő és az azt kirajzoló részből. Az építő
rész\footnote{Cabanier et al.: i. m., 5. fejezet.} függvényei a következők:
\begin{itemize}
  \item a \func{moveTo(x, y)} egy új alakzatrészt kezd el a megadott ponttal,
  \item a \func{closePath()} bezárja az addig épített alakzatrészt (ha volt
  ilyen),
  \item a \func{lineTo(x, y)} egy szakaszt ad hozzá az utolsó pont és
  a megadott koordináta között,
  \item a \func{quadraticCurveTo(cpx, cpy, x, y)} egy másodrendű Bézier
  görbét határoz meg az utolsó pont, a megadott kontroll- és végpont között,
  \item a \func{bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)} egy harmadrendű
  Bézier görbét jelent az utolsó pont és a megadott kontrollpontok és végpont
  között,
  \item az \func{arcTo(x1, y1, x2, y2, radius)} megad egy \func{radius} sugarú
  körcikket az utolsó
  pont és a megadott két koordináta által meghatározott szögben úgy,
  hogy ha kell, akkor egy szakaszt is húz az utolsó pont és körcikk kezdő
  pontja között,
  \item az \func{arc(x, y, radius, startAngle, endAngle, counterclockwise)} a
  változók szerint meghatároz egy körcikket, szükség esetén egy összekötő
  szakasszal,
  \item \func{a rect(x, y, w, h)} pedig egy külön téglalap alakzatrészt ad a
  Path-hoz.
\end{itemize}

A fenti függvényekkel tetszőlegesen bonyolult alakzatok adhatók meg. Ez elemek
egy listáját jelenti, ahol az elemek pontjait egyenes vagy speciális görbe
vonal köti össze, esetleg az elem azt jelöli, hogy egy-egy alakzat zárt. A
függvények paraméterei -- egy kivételével -- mind lebegőpontos típusok
(\func{float}). A kivétel a körcikk körbejárásának irányát leíró logikai
paraméter, a \func{counterclockwise}.

A rajzoló rész függvényei pedig a következők\footnote{Cabanier et al.: i.
m., 11. fejezet.}:
\begin{itemize}
  \item a \func{beginPath()} új Path-t definiál, azaz, ha már volt épített
  alakzat, akkor azt eldobja,
  \item a \func{fill()} hívására az épített alakzat kitöltött képét a
  megadott beállításokkal kirajzolja,
  \item a \func{stroke()} az épített alakzat körvonalának képét a
  megadott beállításokkal kirajzolja,
  \item a \func{drawFocusIfNeeded(element)} az aktuális alakzat kirajzolásával
   informál, ha az adott elem fókuszban van (nem támogatott függvény),
  \item a \func{clip()} az aktuális alakzat képével kivág a
  rajzolóvásznon (jelenleg nem támogatott függvény),
  \item az \func{isPointInPath(x, y)} megállapítja az adott pontról, hogy az
  alakzat rész-e (jelenleg nem támogatott függvény).
\end{itemize}

Arról már volt szó, hogy az alakzat önmetsző is lehet. Az önmetszés kérdése a
kitöltéskor válik fontossá. A kérdés az, hogy az alakzat által határolt
részekből és az önmetszés alkalmával létrejövő lyukakból pontosan melyeket kell
kitölteni. A Canvas API csak egy kitöltési szabályt ír elő. Viszont a legtöbb
-- az előírást megvalósító -- renderelő API támogatja a két legelterjedtebb
kitöltési stratégiát, szabályt. Ezek a \emph{paritás szabály}
(\inenglish{even-odd fill rule}) és a \emph{nem-zérus szabály}
(\inenglish{non-zero fill rule}). Mivel a 2D alakzatrajzolásban mindkettő igen
elterjedt, ezért -- mint később látni fogjuk -- a Gepard API mindkettőt
támogatja. A két szabályt a Pásztázó egyenesek (\ref{Pásztázó egyenesek}.)
részben részletesen ismertetjük.

A itt ismertetett API elvárásokból (is) látszik, hogy a Canvas által
biztosított alakzatrajzolás jó néhány nem triviális formát is lehetővé tesz.
Ezért is fontos, hogy milyen módszerrel közelítjük majd meg az alakzatok
renderelését.

    \section{Az OpenGL~ES~2.0 API}
    \label{GLES2:API}

Az OpenGL~ES~2.0 (GLES2) azaz az \emph{Open Graphics Library for Embeded System
2.0}-ás verziója a \emph{Khronos Group} által felügyelt grafikus
függvénykönyvtár.  Segítségével majdnem közvetlenül adhatunk parancsokat a
grafikus egységnek. Az API-t alapvetően 3D modellek megjelenítésére
használhatjuk. Viszont maga az OpenGL egy hatalmas, komplex függvénykönyvtár.
Kisebb, hordozható eszközök esetén nincs szükség ekkora komplexitásra. Részben
ezért is vezették be az ,,asztali'' OpenGL megrostálása és egyszerűsítése révén
az ES API verziókat. Az ES verziók közül a 2.0-ás lett a
legelterjedtebb\footnote{The Khronos Group: \emph{OpenGL ES Overview}, 2018,
\footnotesize{\url{https://www.khronos.org/opengles/}}\label{fn:GLES2}}.
Viszonylag szigorú megkötések és a kevés számú függvény ellenére jól
használható. Ettől a verziótól már lehetővé vált a \emph{programozható grafikus
végrehajtási modell} (\inenglish{programmable graphics
pipeline}).\textsuperscript{\ref{fn:GLES2}} Ami azt jelenti, hogy a végrehajtási
sorrendbe ugyan nem lehet belenyúlni, de az egyes lépésekben futó részek
programozhatók (lásd az \emph{\ref{opengles_20_pipeline2}. ábrát}).

Nézzük meg röviden a GLES2 működését és a dolgozat szempontjából fontosabb
megkötéseit.

A használható primitív alakzatelemek geometriai típusuk szerint a következők:
\emph{pont}, \emph{szakasz} és \emph{háromszög}. Ezek közül kitöltésre effektív
csak a háromszöget használhatjuk. Három típusát engedi a szabvány:
\emph{háromszög}, \emph{háromszögszalag} (\inenglish{triangle strip}) és
\emph{háromszög-legyező} (\inenglish{triangle fan}). Tehát az egyik és a
számunkra legfontosabb megkötés az, hogy a megjeleníteni kívánt alakzatot
háromszögekkel kell lefednünk.

  \begin{figure}
    \includegraphics[scale=0.5]{img/built/gles2pipeline_eps}
    \caption{\label{opengles_20_pipeline2} Az OpenGL ES 2.0 programozható
    grafikus végrehajtási modellje. A \emph{vertex shader} és a \emph{fragment
    shader} lépéseket programozhatjuk. \\%
    (A {\footnotesize\url{https://www.khronos.org/api/opengles/2_X}} forrás
    alapján.)
    }
  \end{figure}

Bármilyen megjelenítéshez írni kell legalább két programot, ami a grafikus
egységen fog lefutni. Az első program kódját adja meg az ún. \emph{vertex
shader}, a másodikét pedig a \emph{fragment shader}. Ezeket a leírásokat a
grafikus meghajtónak át kell adjuk, hogy az \emph{lefordíthassa}
(\inenglish{compiling shader}) és \emph{összeköthesse} (\inenglish{linking
programs}) azokat. Hibátlan fordítás és összekötés esetén visszakapunk egy
\emph{program azonosítót}.  Később erre az azonosítóra hivatkozva állíthatjuk be
a végrehajtási modell \emph{állapotát} (pipeline \inenglish{state}).

A vertex shader segítségével határozhatjuk meg a \emph{csúcspontokra}
(\inenglish{vertex}) lefutó programot. A vertex programmal adhatjuk meg a
csúcspont végleges helyét.  Lehetőségünk van az adott csúcsponthoz tartozóan
változókat (\inenglish{varyings}) beállítani, amiket a később lefutó fragment
shader-ben felhasználhatunk. Ahhoz, hogy a program lefusson a GPU oldalon,
előbb még be kell állítanunk néhány dolgot a CPU oldalon. Egyrészt össze kell
állítani egy puffert (tömböt) a csúcspontokhoz tartozó adatokkal, ezt
\emph{vertex attribútum tömbnek} nevezzük. A vertex shaderben az
\func{attribute} kulcsszóval különböző bemeneti paramétereket határozhatunk
meg. Ezeket be kell ,,kössük'' a CPU oldalon. Azaz a grafikus meghajtót
értesítenünk kell róla, hogy milyen néven és milyen típusú adatot keressen a
vertex programot leíró shaderkódban. Ezeknek az attribútumoknak a közös méretét
\emph{lépéshossznak} (\inenglish{stride length}) nevezzük, és minden
csúcsponthoz tartoznia kell egy ekkora méretű leírásnak az előbb említett
tömbben. Nem kötelező azonban, hogy csak egy attribútum tömböt használjunk.
Lehetőség van minden bemeneti attribútumhoz külön tömböt lefoglalni és bekötni.
A feladathoz érdemes igazítani. Ha több csúcsponthoz is ugyanazokat az
értékeket adnánk át, akkor érdemes az egy tömböt alkalmazó modellt használni.
Ilyenkor azonban meg kell adnunk egy indextömböt is. Minden csúcsponthoz hozzá
kell rendelni az attribútumtömb egy lépéshossznyi elemét. Az indextömb esetén
is két lehetőség közül választhatunk. Egyrészt megadhatjuk a
rendereléskor\footnote{A renderelést a \func{glDrawElements} vagy a
\func{glDrawArrays} függvények hívása jelenti.}.  Másrészt egy egészen korai
szakaszban készíthetünk egy viszonylag nagy (akár $65536$ elemű) indextömböt,
és ezt feltölthetjük a GPU oldalra. Ha pedig a renderelés pillanatában nem
adunk meg indextömböt, akkor sorra ebből a feltöltött pufferből veszi az
indexeket. Ez az utóbbi megoldás akkor lehet hasznos, ha nagyon sok hasonló
geometriai elemet (pl. trapézokat) szeretnénk ismétlődő attribútumokkal
kirajzolni. Ilyenkor az indextömböt könnyedén generálhatjuk, és többször is
felhasználhatjuk.

Hasonlóan a vertex shaderhez, a \emph{fragment shader} esetében is be kell
állítanunk a megfelelő értékeket. A shaderkódban használt \emph{texturák}
(\inenglish{textures}) vagy \emph{egyedi változók}
(\inenglish{uniform})\footnote{Természetesen \func{uniform} értékeket a vertes
shader-ben is használhatunk.} elnevezését szintén be kell kössük CPU oldalon.
Az egyedi változókat fel kell tölteni a megfelelő értékkel. A fragment shader
kódjából fordított program a csúcspontok által kifeszített háromszögek
területére eső raszterpontokra fog lefutni.  Ha lefut a program, az azt
jelenti, hogy a raszterpont egy ilyen csúcspont-hármas által meghatározott
háromszögbe esik. A bemenő paraméterek értékei közül a változók
(\inenglish{varyings}) interpolálva lesznek feltöltve. Ha a raszterpont
valamelyik csúcspontra esik, akkor annak a csúcspontnak megfelelő értékeket
kapja meg. Ha a háromszögbe esik, akkor az interpoláció típusának megfelelően a
három ponttól vett távolságainak függvényében kap értékeket az adott
változókba.

Ha megadtuk a shader kódokat, lefordítottuk, és bekötöttük azokat, akkor a már
említett puffereket (attribútum, index stb.) kell feltöltenünk. Meg kell adnunk
egy eredmény puffert is, ahová a kirenderelt képet várjuk. Ez egy úgynevezett
\func{Frame Buffer} típusú tömb lesz. Ezek után valamelyik renderelést kiváltó
függvény hatására a grafikus meghajtó összegyűjti a rajzoláshoz szükséges
adatokat, és átmásolja a GPU oldalra. Majd elkezdi feldolgozni.

Az eredményt nem azonnal kapjuk meg, a folyamat a grafikus meghajtótól függ.
Ugyanakkor vannak bizonyos CPU oldali függvények, amik blokkoló hatásúak, azaz
bevárják az eredmény elkészültét. Ilyen például a \func{glReadPixels}. Ezzel
függvénnyel olvashatunk ki az eredménytömbből. Világos, hogy valós adatot
olvashassunk ki ebből a tömbből, garantálnunk kell, hogy abban a végső kép el
is készült.

Fontos fogalom még a \emph{textúra} (\inenglish{texture}). A textúra valamilyen
típusú és méretű leírás egy a GPU-n lévő tömb felett. Dimenziója szerint lehet
2D vagy 3D valamilyen formája. A mi esetünkben ez mindig 2D
(\func{GL\_TEXTURE\_2D}). Így rendelkezik egy szélességgel és magassággal,
valamilyen csatornatípussal (\func{GL\_ALPHA}, \func{GL\_RGBA} stb.) és a
csatornánkénti értékek méretével (pl. \func{GL\_UNSIGNED\_BYTE}). Nagy
vonalakban ezekkel értelmezhető egy a GPU-n lefoglalt memória leírása. Ilyen
textúrákba renderelhetünk, vagy ezekből olvashatunk ki adatokat. Természetesen,
hogy hívatkozni tudjunk a textúrákra a shader kódokban, ahhoz azokat is be kell
kössük még a renderelés előtt. Illetve ha forrás textúráról van szó, akkor
szükséges CPU oldali tömböt is rendelnünk hozzá. Ezek az adatokat is majd a
renderelést kiváltó függvény hívásakor töltődnek fel a GPU memóriájába.

Ahhoz, hogy minél hatékonyabban kihasználjuk a CPU oldaltól függetlenül
renderelő GPU nyújtotta lehetőséget, annál több adatot kell egyszerre, vagyis
csokorban (\inenglish{batching}) átadnunk. Ezért pl. trapézok egy sorozatát nem
egyenként érdemes kirenderelni, hanem az adatokat összerakni a már említett
attribútum tömbökbe, és egyszerre kirendereltetni a lehető legtöbbet.
Elképzelhető, hogy olyan sok elemet kell kirenderelni, hogy a tömbök méretére
vonatkozóan felső korlátba ütközünk. Ez a felső korlát jellemzően vagy az
index- vagy az attribútum tömb maximális $65536$-os mérete. Ilyenkor ismételt
lépésben kell rajzolni. Ekkor azonban a kétszer érintett raszterpontok értéke
nem várt módon elromolhat. Ezt befolyásolhatjuk az ún. \emph{összhatásmóddal}
(\inenglish{blending mode}). A jól megválasztott összhatásmód\footnote{A
megszakított, lépésenkénti renderelés esetén ez a forrás- és céltextúrára is a
\func{GL\_ONE}.} segítségével elérhető, hogy egyben történő renderelésnek
látszik az is, amit külön lépésekben rajzoltunk.

Az eredményképünk a GLES2-es definíció szerint mindig a $0$ azonosítójú Frame
Buffer típusú tömbbe kerül. Vagyis innen lehet kiolvasni, vagy az aktuális
ablakozót értesíteni (pl. \emph{eglSwapBuffers} hívással) a képernyőn való
megjelenítéshez.

    \section[Matematikai háttér]{Matematikai háttér}
    \label{Matematikai háttér}

Az előző két fejezetrészben láthattuk, hogy tetszőlegesen bonyolult (akár
önmetsző) alakzatokat is ki kell tudjunk rajzolni, renderelni. Ehhez viszont
maximum csak háromszögeket használhatunk. Ebben a részben azt a néhány fontosabb
matematikai hátterű fogalmat, tulajdonságot vagy módszert mutatjuk be, amit az
implementáció során felhasználtunk.

    \subsection*{Pásztázó egyenesek}
    \label{Pásztázó egyenesek}

A \emph{pásztázó egyenesek módszere} (\inenglish{scan-line algorithm}) egy
grafikai algoritmus alakzatok kitöltésére, vagy pont tartalmazásának
eldöntésére.

Az algoritmus jól ismert a számítógépes ábrázolás területén.\footnote{Foley et
al.: \emph{Computer Graphics: Principles and Practice (2Nd Ed.)}, Boston, 1990,
Addison-Wesley Longman, 209. és 431. o.} Bár a módszer igen egyszerű és
közismert, azért nagy vonalakban ismertetjük. Kiemelve azokat a tényezőket,
amelyek a dolgozat szempontjából fontosabbak.

Vegyük az alakzatokat leíró elemek listáját. Fontos, hogy mindig zárt
alakzatokról van szó, ha a módszert vizsgáljuk. Az egyszerűség kedvéért a
leírást végezzük síkban. Ugyanakkor belátható, hogy a módszer térben is működne.
Vegyük az alakzatokat leíró elemek koordinátáit. Válasszuk ki valamelyik
dimenziót (például az $y$-t). Keressük meg a választott dimenzió mentén a
koordináták közül a legkisebbet. Ezután válasszunk egy olyan pontot a síkon
aminek a választott dimenziójú értéke még ennél is kisebb. Indítsunk pásztázó
vonalakat minden irányba ebből a pontból. Ekkor lesznek olyan vonalak, amelyek
nem érintik egyik alakzatot sem. Viszont lesznek olyanok, amelyek metszik
valamelyik alakzatelemet. A metszések és azok sorrendje a pásztázó egyenesen
kulcsfontosságúak. Aszerint, hogy milyen kitöltési stratégiát választunk,
nyernek értelmet a metszéspontok.

Vegyük elsőnek a \emph{paritás szabályt} (\inenglish{even-odd fill rule}). A
kiindulási ponttól egészen az első metszéspontig a pásztázó egyenes által
érintett pontokat nem jelöljük. Az első metszésponttól a következőig minden
pontot jelölünk, majd megint nem jelöljük a rákövetkezőig, és így tovább. Egy
pont az alakzat része, ha meg van jelölve. A megjelölt pontok összességének képe
a kitöltött alakzatok képe.

A másik elterjedt a \emph{nem-zérus szabály} (\inenglish{non-zero fill rule}).
Ahhoz azonban, hogy ezt a szabályt alkalmazni tudjuk, ismernünk kell az
alakzatokat leíró elemeknek az irányítását. Ez lehet például a definiálás
sorrendje szerinti haladásirány. Itt a kiindulási pontól minden pontot zérussal
jelölünk, majd az első metszéspontnál vesszük a pásztázó vonal és az elem
irányításának keresztszorzatát. Az előjel szerint az eddigi zérus értékhez
hozzáadunk vagy kivonunk egyet, és a következő metszéspontig ezzel az értékkel
jelöljük a pontokat. A következő metszéspontban hasonlóan járunk el, és az
addigi értéket szintén eggyel módosítjuk. Egy pont az alakzat része, ha nem
zérus. Minden nem zérus pont együttes képe a kitöltött alakzatok képe.

Természetesen a számítógépes ábrázolásban nem egy pontból indítjuk a pásztázó
vonalakat. A raszterkép valamelyik oldalára merőlegesen minden pontsorhoz
rendelünk egy a végtelenből jövő pásztázó vonalat. Ezek a vonalak teljesen
ekvivalensek a geometriaiakkal. Azzal a megkötéssel, hogy a raszterpontok
megjelölésére olyan szabályt kell alkalmazni, hogy a nem raszterpont-határra eső
és érintkező alakzatok ne jelöljék meg kétszer ugyanazt a raszterpontot.
Természetesen nem is pásztázó egyenesekről, hanem adott magasságú \emph{pásztázó
sávokról} beszélünk. A pásztázó sávok fogalma még fontos lesz a dolgozat
szempontjából.

    \subsection*{\emph{Bézier} görbe és a \emph{de Casteljau} felbontás}
    \label{Bézier görbe és a de Casteljau felbontás}

A \emph{Bézier} (vagy \emph{de Casteljau}) görbecsalád jó tulajdonságai miatt
népszerű~\footnote{Foley et al.: i. m., 598. o.} a számítógépes grafikában. Nem
véletlen, hogy a Canvas API előírja a másod- és harmadrendű Bézier görbék
használatát. A következőkben általánosan bemutatjuk a Bézier görbéket és azok
tulajdonságait. Megvizsgáljuk a de Casteljau felbontást, és bemutatjuk néhány
olyan előnyét, amely indokolja a használatát.

Az alábbiakban definiáljuk a Bézier-görbéket. A definícióban a ,,pont'' fogalmát
nem szűkítjük a síkra, ugyanakkor világos, hogy a dolgozat esetében elégséges
erre a speciális esetre gondolnunk.

\begin{defi}\label{Bézier}\cite[Kurusa]{Kurusa:1999:szamitogepes} Legyen adott
az ($n+1$)-darab $p_0,...,p_n$ pont. Ezeket Bézier, vagy kontroll pontoknak, az
általuk meghatározott poligont pedig kontrollpoligonnak nevezzük.  Indukcióval
definiáljuk a következő pontokat, minden $t \in [0,1], k \in \{{0,1,2,...,n\}}$
és $i \in \{{0,1,2,...,n-k\}}$ esetére: \[p^0_i(t)=p_i,\]
\[p^k_i(t):=(1-t)p^{k-1}_i(t) + tp^{k-1}_{i+1}(t).\] Ekkor azt a görbét, amit a
$p^n_0(t)$ pont leír, ahogy a $t$ végig fut a $[0,1]$ intervallumon, Bézier
görbének nevezzük, és $B(t)$-vel jelöljük. A $p^k_i(t)$ pontokat de Casteljau
pontoknak, az $n$ számot pedig a görbe rendjének hívjuk.  \end{defi}

  \begin{figure}
  \psfrag{a}[b][B][0.9]{\emph{a.}}
  \psfrag{P0}[b][B][0.8]{\bf{$p_{0}$}}
  \psfrag{P1}[b][B][0.8]{\bf{$p_{1}$}}
  \psfrag{P2}[b][B][0.8]{\bf{$p_{2}$}}
  \psfrag{P3}[b][B][0.8]{\bf{$p_{3}$}}
  \psfrag{P01}[b][B][0.8]{\bf{$p_{0}^{1}$}}
  \psfrag{P02}[b][B][0.8]{\bf{$p_{0}^{2}$}}
  \psfrag{P11}[b][B][0.8]{\bf{$p_{1}^{1}$}}
  \psfrag{P12}[b][B][0.8]{\bf{$p_{1}^{2}$}}
  \psfrag{P21}[b][B][0.8]{\bf{$p_{2}^{1}$}}
  \psfrag{P03}[b][B][0.8]{\bf{$p_{0}^{3}$}}
  \psfrag{b}[b][B][0.9]{\emph{b.}}
  \psfrag{Q0}[b][B][0.8]{\bf{$p_{0}$}}
  \psfrag{Q1}[b][B][0.8]{\bf{$p_{1}$}}
  \psfrag{Q2}[b][B][0.8]{\bf{$p_{2}$}}
  \psfrag{Q01}[b][B][0.8]{\bf{$p_{0}^{1}$}}
  \psfrag{Q02}[b][B][0.8]{\bf{$p_{0}^{2}$}}
  \psfrag{Q11}[b][B][0.8]{\bf{$p_{1}^{1}$}}
    \centering
    \includegraphics[width=.95\textwidth]{img/built/beziers_eps}
    \caption{\label{beziers} Bézier görbék. Az \emph{a. ábra} harmadrendű, a
    \emph{b. ábra} másodrendű görbe képét, kontrollpoligonját és de
    Casteljau pontjait mutatja.}
  \end{figure}

A definícióból következik néhány tulajdonság. Nézzük ezek közül a számunkra
legfontosabbakat:
\begin{itemize}[noitemsep,topsep=0pt]
  \item a Bézier görbe mindig a kontrollpoligon első pontjától ($t=0$) kezdődik,
  és az utolsó pontjánál ($t=1$) ér véget\footnote{Kurusa -- Szemők: \emph{A
  számítógépes ábrázoló geometria alapjai}, Szeged, 1999, Polygon, 42. o.},
  \item a $k$-adik rendű kontrollpoligon $t/(1-t)$-ad felosztása megadja a
  ($k-1$)-edik kontrollpoligont, amit tovább osztva a $t/(1-t)$ aránnyal, s
  ezzel eggyel csökkentve a kontrollpoligon oldalainak számát, végül már csak
  egy pontot kapunk, ami a Bézier görbe $t$ paraméteréhez tartozó pontja, és az
  eljárást pedig \emph{de Casteljau felbontásnak} neveztük (\emph{\ref{beziers}.
  ábra})\footnote{Kurusa -- Szemők: i. m. 41--42. o.},
  \item az elsőrendű Bézier görbe alakja egy \emph{egyenes}\footnote{Kurusa --
  Szemők: i. m. 43. o.\label{fn:Kurusa:43p}},
  \item az egy egyenesre eső kontrollpontok által meghatározott Bézier görbe
  alakja szintén egy egyenes\textsuperscript{\ref{fn:Kurusa:43p}},
  \item a másodrendű Bézier görbe alakja egy \emph{parabola}
  (\emph{\ref{beziers}. ábra b.} pontja)\textsuperscript{\ref{fn:Kurusa:43p}},
  \item a Bézier görbe mindig a kontrollpoligon konvex burkában
  van\textsuperscript{\ref{fn:Kurusa:43p}},
  \item a Bézier görbe az affin transzformációkra invariáns, azaz a görbe affin
  képe megegyezik a kontrollpoligon affin képe által meghatározott Bézier
  görbével\textsuperscript{\ref{fn:Kurusa:43p}}.
\end{itemize}

A fenti tulajdonságokból is jól látszik, hogy miért lett népszerű a számítógépes
grafikában ez a görbecsalád.

A $t$ paraméterhez tartozó pont az $n$-ed rendű Bézier görbét két, ugyancsak
$n$-ed rendű görbére osztja\footnote{Kurusa -- Szemők: i. m. 47. o.}. A két
görbe kontrollpontjai pedig az eredeti görbe de Casteljau pontjai közül kerülnek
ki. A fenti tulajdonságokat és a definícióban leírt indukciós elnevezést
figyelembe véve a két $n$-ed rendű görbe kontrollpontjai a következők:
\begin{equation}\label{eq:1} B_{0\mapsto t}^n(t): p_0, p_0^1, ..., p_0^{n-1},
p_0^n; \qquad B_{t\mapsto 1}^n(t): p_0^n, p_1^{n-1}, ..., p_{n-1}^1, p_n.
\end{equation}

\Aref{eq:1} felbontást később majd használni fogjuk. Világos, hogy a felbontást
tovább alkalmazva a görbe darabokon, végül a görbe darabok végpontjait sorban
összekötő egyenesek megközelítik az eredeti görbét.

    \subsection*{Körívek közelítése Bézier görbékkel}
    \label{arctobezier}

A dolgozatban tárgyalt módszerrel az alakzatokat trapézokkal fedjük le. Ezért
szükséges a köríveket szakaszokkal közelíteni. A Bézier görbéket a de Casteljau
felbontással gyorsan közelíthetjük szakaszokkal. A köríveket pedig gyorsan
közelíthetjük Bézier görbékkel. Néhány lépésben megállapítható, hogy egy adott
sugarú körcikket hány darab harmadrendű Bézier görbével fedhetünk le egy
$\epsilon$ hibahatáron belül.

Egy $\alpha$ szögű körcikk tökéletesen nem fedhető le Bézier
görbékkel\cite[Goldapp]{Goldapp:1991:approximation}. Azonban jól és gyorsan
közelíthető harmadrendű Bézier görbékkel.

Az említett \cite[Goldapp]{Goldapp:1991:approximation} tanulmány bemutat egy
lehetséges stratégiát a körcikkek közelítésére. Egy $\alpha$ szögű körcikk
esetén meghatározhatunk egy harmadrendű Bézier görbét, és megadhatjuk a két
görbe közti eltérését leíró $\epsilon_{\alpha,h}(t)$ függvényt\footnote{M.
Goldapp: \emph{Approximation of circular arcs by cubic polynomials}, North
Holland, 1991, Elsevier, 231. o.}. Az eltérést leíró függvény képe függ a Bézier
görbe alakjától. Ha azonban az \emph{\ref{circle}. ábrán} látható módon
szimmetrikusan határozzuk meg a Bézier görbét, akkor a maximális eltérés a
$t=\frac{1}{2}$ értéknél adódik.\footnote{M. Goldapp: i. m., 230. o.}

  \begin{figure}
  \psfrag{0}[b][B][0.8]{\bf{$0$}}
  \psfrag{1}[b][B][0.8]{\bf{$1$}}
  \psfrag{x}[b][B][0.8]{\bf{$x$}}
  \psfrag{y}[b][B][0.8]{\bf{$y$}}
  \psfrag{a}[b][B][0.8]{\bf{$\alpha$}}
  \psfrag{C}[b][B][0.8]{\bf{$\epsilon_{\alpha,h}(\frac{1}{2})$}\qquad}
  \psfrag{P0}[b][B][0.8]{\bf{$\begin{bmatrix} 1 \\ 0 \end{bmatrix}$}}
  \psfrag{P1}[b][B][0.8]{\bf{$\begin{bmatrix} 1 \\ h \end{bmatrix}$}}
  \psfrag{P2}[b][B][0.8]{\bf{$\hspace{3cm}\begin{bmatrix}\cos\alpha\\ \sin\alpha
                              \end{bmatrix} + h \begin{bmatrix} \sin\alpha \\
                              -\cos\alpha \end{bmatrix}$}}
  \psfrag{P3}[b][B][0.8]{\bf{$\begin{bmatrix}\cos\alpha\\ \sin\alpha
                              \end{bmatrix}$}}
    \centering
    \includegraphics[width=.5\textwidth]{img/built/circle_eps}
    \caption{\label{circle} Körcikk (szaggatott vonal) és a hozzá
    $\epsilon(t=\frac{1}{2})$, maximális eltérésben illeszkedő harmadrendű
    Bézier görbe (sima vonal).}
  \end{figure}

Vegyünk egy $\alpha$ szögű egységsugarú körcikket, ekkor a fenti módon leírt
Bézier görbe kontrollpontjai a következők:
\[p_0 = \begin{bmatrix} 1 \\ 0 \end{bmatrix},\quad
  p_1 = \begin{bmatrix} 1 \\ h \end{bmatrix},\quad
  p_2 = \begin{bmatrix} \cos\alpha \\ \sin\alpha \end{bmatrix} + h
        \begin{bmatrix} \sin\alpha \\ -\cos\alpha \end{bmatrix},\quad
  p_3 = \begin{bmatrix} \cos\alpha \\ \sin\alpha \end{bmatrix}, \]
ahol a $h$ egy szabad paraméter. Pontosabban $h$ függ a körcikk $r$ sugarától.
Az is világos, hogy adott $\alpha$ szögnél nagyobb körcikk kellő pontosságú
megközelítéséhez nem elégséges egy darab harmadrendű Bézier görbe.

Legyen $h_1$ a $h$ egy speciális értéke az egységsugarú körcikk
esetén\footnote{M. Goldapp: i. m., 230. o.}: $h_1 = \frac{4}{3} \tan{\frac{1}{4}
\alpha}$. Ekkor a \cite[Goldapp]{Goldapp:1991:approximation} tanulmányban
említett\footnote{M.  Goldapp: i. m., 231. o., (16)-os képlet.} képlet
segítségével megkaphatjuk a maximális eltérés mértékét: \begin{equation}
\label{eq:2} |\epsilon_{max} = \max_{{t\in[0, 1]}} \epsilon(t)| = \frac{4}{27}
\frac{\sin^6{\frac{1}{4} \alpha}}{\cos^2{\frac{1}{4} \alpha}}. \end{equation} Ha
a kapott $\epsilon_{max}$ nem kellően kicsi, akkor a körcikk felbontásával (pl.
felezésével) csökkenthetjük az eltérések mértékét. A folyamatot egészen addig
újra elvégezhetjük, amíg minden körcikk-darabnál nem lesz kellően kicsi az
eltérés. Ezután $h_1$ és a szögek ismeretében megkaphatjuk a Bézier görbék
kontrollpontjait.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Alakzatrajzolás                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter{Alakzatrajzolás}

A \emph{Gepard} tervezésekor fontos szempont volt, hogy ne csak az OpenGL
rajzoló modullal működjön. Vagyis lehetőséget kell kínálni, hogy a jövőben több
grafikus meghajtóval is tudjuk használni. Mint például a Vulkan, DirectX,
esetleg egy referencia szoftveres raszterizáló. Ezért a Gepard három részre
tagolódik (lásd a \emph{\ref{structure_eps}. ábrát}). A \emph{felső} réteg
alapja a Canvas API. Ezt neveztük el \emph{Gepard}-nak. A következő
\emph{köztes} réteg fogja össze a közös részeket. Ez lett a \emph{Gepard
Engine}. A \emph{Gepard Backend} pedig az \emph{alsó} szint, ahol az egyes
grafikus meghajtók specifikus részei kaptak helyet. Három modul fejlesztése
történik itt: \emph{GLES2} (OpenGL ES 2.0), \emph{Vulkan} (Vulkan 1.0) és
\emph{Software} (saját raszterizáló).
  \begin{wrapfigure}{\melyikoldalra}{0.5\textwidth}
    \includegraphics[scale=0.45]{img/built/structure_eps}
    \caption{\label{structure_eps} A három fő réteg}
  \end{wrapfigure}
Ezeket a modulokat vagyis az ún. Backend-eket jelen pillanatban
\func{GepardEngineBackend} néven fordítási időben adjuk hozzá Gepardhoz, és
ezáltal a Gepard egy adott grafikus meghajtóra speciálisan lefordított
függvénykönyvtár lesz. Ugyanakkor a köztes (az Engine) és az alsó réteg
(valamelyik Backend) tervezéskori pontos szétválasztásának köszönhetően a
jövőben ez akár futás időben is megtörténhet. Javítva ezzel is az átjárhatóságot
a grafikus meghajtók között, és könnyebbé téve a Gepard használatát.

Most nézzük meg részletesebben a fent említett három réteget. Természetesen az
egyes rétegekhez kapcsolódó főbb részek, melyek tulajdonképpen a dolgozatunk
témája, külön fejezetben lesznek tárgyalva. Tehát most csak a rétegek
bemutatásához szükséges módon említjük meg ezeket.

    \subsection*{A felső réteg, azaz a Gepard interfész}

A felső réteget a \func{Gepard} osztályt \aref{Háttér}. fejezetben tárgyalt
Canvas határozza meg. Természetesen  a Canvas alapvetően egy webes interfész.
Ez azt is jelenti, hogy a \func{Gepard} nem teljesen úgy működik mint a Canvas
API a webes környezetben. A cél nem is az volt, hogy pontosan lemásoljuk. A cél
egy a C++ környezetben könnyen használható -- a webes szcénában már jól
kipróbált -- kezelőfelületet adjunk. Érdemes röviden átnézni ezt a felületet.

A Canvas API két csoportra osztható. Az egyik a hívható függvények, a másik a
beállítható adattagok csoportja. Tehát a Gepard interfész is többnyire ezt a
felosztást és működést próbálja meg követni. A hívható függvények tekintetében
egyszerűbb a helyzet. Hiszen az API által leírt függvények szemantikája nagyon
hasonló a C++ által elvártakhoz. A C++ környezet ugyan kissé megkötőbb. Például
szövegként (\inenglish{string}) átadott számértéket nem fogad el a szigorú
típusosság miatt. Ez azonban nem tekinthető durva megkötésnek, hiszen egyrészt
elemző-értelmező függvényekkel (\inenglish{parser functions}) az átváltások
biztosíthatók, és ugyanakkor az alap konverziók (\inenglish{cast}) továbbra is
működnek.

A függvények döntő része 32 bites lebegőpontos (\func{float}) vagy egész
(\func{int}) számot vár paraméterként. Ezért ezek könnyedén kezelhetők.
Ugyanakkor pár metódus esetében szükségszerű bevezetni saját típusokat,
osztályokat, struktúrákat, hogy a Canvas-hez hasonló viselkedést biztosíthassuk.
Ilyen osztály lett például az \func{Image}, amit többek között a
\func{putImageData()} függvény miatt kellett bevezetni. Szerencsére ezek az
osztályok is jól definiáltak a Canvas szintjén, vagyis szerkezetük jobbára
könnyen megadható.

A másik csoport a módosítható adattagoké (\inenglish{attributes}). Itt a
viselkedés kényelmes biztosításához saját osztályt kellett írni. Ez lett az
\func{Attribute} osztály. A bevezetésének szükségességét a \func{fillStyle}
adattagon keresztül mutatjuk be.

A \func{fillStyle} definíció szerint egy CSS attribútum vagyis adattag. Ez azt
jelenti, hogy igen sokféleképpen lehet értéket adni neki. A C++ szigorú
típusossága miatt egyszerű, ún. primitív típussal nem is megoldható, annak
ellenére, hogy ez az adattag alapvetően csak a kitöltés színét tárolja.
Ugyanakkor a beállítás módja lehet hexa-kód
(\func{\#0f0}~vagy~\func{\#00ff00}), egy előre definiált név (\func{green}),
esetleg egy függvényszerű leírás vagy egy másik adattag értéke. Azáltal, hogy
az \func{Attribute} osztályt bevezettük, lehetőség nyílt az adattagok kényelmes
értékadásának.

Nézzük meg röviden ezt az osztályt is. Tehát mint már az előbb említettük
egyrészt, az értékadás sokféleségét biztosítani kellett. Ugyanakkor nem csak az
értékadás lehet többféle, hanem az adattagok ,,típusa'' is. Vagyis az említett
\func{fillStyle}-hoz képest más típusú adatot tároló módon is kellett tudjon
működni az \func{Attribute} osztály. Az értékadás sokféleségét a
\emph{paraméteres} és az \emph{ad hoc polimorfizmus}\footnote{ A kifejezést az
azonos nevű de különböző típusú és számú argumentummal rendelkező függvényekre
\textsc{Christopher Strachey} honosította meg. Forrás: Christopher Strachey:
\emph{Fundamental Concepts in Programming Languages}, in Higher-Order and
Symbolic Computation, Kluwer Academic Publishers, 2000, 13, 11–49.} biztosítja.
A bonyolultabb értékadásokat (pl. függvény leírás) pedig egy a példányosításkor
bekötött elemző-értelmező függvény végzi.
  \begin{wrapfigure}{\melyikoldalra}{0.4\textwidth}
    \begin{center}
      \includedataflowkivagas{0pt}{210pt}{160pt}{590pt}{}
    \end{center}
    \caption{\label{dataflow-API-diagram} A \emph{felső} réteg (Gepard
    interfész) függvényei és adattagjai. \\ (Részlet a
    \emph{\ref{dataflow}. folyamatábrából}.)}
  \end{wrapfigure}
Az így bekötött függvény az értékadáskor meghívódik (visszahívódik,
\inenglish{callback}), és a kapott szöveget értelmezi, majd a megfelelő
adattagot immáron a középső rétegben vagyis a \func{Gepard Engine}-ben
beállítja.

A \emph{\ref{dataflow-API-diagram}. ábrán} a Canvas API-nak a Geprad
interfészben az alakzatrajzoláshoz szükséges és szorosan kapcsolódó függvényei
és adattagjai láthatók. A függvényeket a nevük utáni zárójelpár jelzi. Az egyes
függvények paramétereit itt nem tüntettük fel, ezek úgy is megtalálhatók
részletesebben is kifejtve az API dokumentációjában. A zárójelpár nélküli nevek
az egyes adattagok. Ezekről is tartalmaz bővebb leírást a dokumentáció. A
megvalósított API részek -- a gradiens színezést és a szaggatott vonallal
rajzolást leszámítva -- teljes körű alakzatrajzolást biztosítanak számunkra.
Erre láthatunk majd példát az eredményeket bemutató fejezetben
(\ref{Eredmények}). Az ábrán nem tüntettük fel a többi -- a dolgozatot nem
érintő API függvényt és adattagot.

Tehát az itt bemutatott \emph{felső} réteg vagyis a \func{Gepard} egy C++
interfész, ami egy jól bevált Canvas API-ra támaszkodik, és teremt kapcsolatot
a felhasználó és a következő ún. \emph{köztes} réteg között.

    \subsection*{A köztes réteg, azaz a GepardEngine osztály}

A köztes réteg már valamivel bonyolultabb. Egyrészt használja a grafikus
meghajtó specifikus alsóbb szintű réteget, előállítva a kívánt képet. Másrészt
tartalmazza és megvalósítja a közös osztályokat. Az egész réteget összefogó
osztály pedig a \func{GepardEngine}. Nézzük át részletesebben az itt
megvalósított részeket.

A \emph{\ref{structure_eps}. ábrán} már láthattuk, hogy ez a szint a jelen
dolgozatot érintő négy főbb részből tevődik össze. Most csak hármat
részletezünk itt. A negyedik részt, azaz a \emph{Path} alakzatleíró és tároló
és az ezt feldolgozó osztályokkal úgy is külön alfejezetekben foglalkozunk.

Az egyik funkcionalitás a rajzolás környezetének (a továbbiakban kontextus,
\inenglish{drawing context})\footnote{A \emph{\ref{structure_eps}. ábrán} ez az
,,Állapot kezelése'' rész.} biztosítása, bizonyos változások elmentése és
helyreállítása. Az elmentésért a \func{save}, a visszaállításért pedig a
\func{restore} API függvények a felelősek. A függvények hívásának hatásai ezen
a rétegen fejtődnek ki. A \func{save} egy verempufferbe teszi az aktuális
kontextus bizonyos beállításait. A \func{restore} pedig kiveszi a soron
következőt. Gyakorlatilag úgy kell értelmezni, hogy a verem tetején lévő
kontextus beállítások az érvényesek, azaz ezeket kell használni. Fontos
megjegyezni, hogy nem minden kontextusbeli elemet mentünk el, vagy állítunk
vissza. Például a transzformációkat, a kivágás alakzatát (\inenglish{clipping
region}) és a legtöbb színezéssel kapcsolatos értékeket igen, de a \emph{Path}
által aktuálisan tartalmazott alakzatot például nem. Itt csak a
legfontosabbakat soroltuk fel, de a Canvas API leírás \cite{Cabanier:14:HCC}
második fejezetében megtalálható a teljes lista.

A második rész a transzformációk. A Háttér részben (\ref{A Canvas előírás}) a
Canvas API bemutatásakor már tárgyaltuk a transzformációkat, itt most csak
röviden a megvalósításukat nézzük át.

Minden kontextus tartalmaz egy transzformációs mátrixot. Ezt a mátrixot a
\func{Transform} osztály valósítja meg. A megvalósítani kívánt mátrix egy
homogén sík koordinátás affin transzformációt tartalmaz. Aminek az alsó sora
ismert ($0\enskip 0\enskip 1$), így csak a felső két sort kell eltárolni. Ez
hat értéket jelent. Ebből a harmadik oszlopban találhatók a síkban eltolás
vektorának értékei. A hat lebegőpontos értéken kívül még megvalósítottuk a
leggyakrabban használt mátrix műveleteket, mint például a szorzás, inverz
számítás, stb.

Alakzatot rajzoló parancsok esetén a rajzolás pillanatában az aktuális
kontextus által tartalmazott mátrixot kell alkalmazni. Ez a primitív alakzatok
esetén könnyebb, hiszen az alakzat egyszerre definiálódik és rajzolódik ki.
Tehát a megfelelő koordinátákat megszorozzuk a transzformációs mátrixszal. A
\emph{Path} esetén figyelnünk kell arra, hogy az alakzat építése közben is
lehetséges a transzformációs mátrix módosítása. Ami azt jelenti, hogy az addig
épített alakzatra érvényesíteni kell a megváltoztatott mátrixot. Ugyanakkor az
alakzatot tovább lehet építeni. Az eltranszformált részt úgy kell felfogni,
mintha eredetileg is így eltranszformálva adták volna meg, vagyis
tulajdonképpen könnyedén folytathatjuk az alakzat építését.

Részben ehhez a réteghez kapcsolódik a kitöltött téglalap (\func{fillRect})
rajzolása is. Ez ugyan szigorúan nem tartozik a szakdolgozatunk tárgyához,
ugyanakkor mint a Path általános alakzatleírás egyik -- külön is definiált --
primitív alakzatként azért érdemes pár szót ejteni róla. Elsőre erre az
egyszerű alakzatra készült el a kirajzolás általános folyamata. Kezdve az API
hívástól (\func{fillRect}) a felső rétegben. Majd haladva a köztes rétegen át a
konkrét kirajzolásig OpenGL ES 2.0-t használva. A téglalapot mint két egymáshoz
illesztett derékszögű háromszöget értelmeztük. A négy sarokra mint vertexekre
hívódott meg egy nagyon egyszerű \emph{program} a grafikus eszközön. Az alakzat
egyszerűsége miatt mind a \emph{vertex}, mind pedig a \emph{fragment}
programrészekhez tartozó ún. árnyaló\footnote{FIXME: magyarul a shader?}
(\inenglish{shader}) kódok viszonylag egyszerűek lettek. Ezért könnyen
felállítható volt a rajzolás folyamata, ahová aztán be lehetett illeszteni a
komplexebb alakzatok megjelenítését.

    \section[A Path osztály]{A Path osztály}
    \label{A Path osztály}

A \func{Path} egy konténer osztály. A fő feladata, hogy az alakzatot és az
ahhoz szorosan kapcsolódó tulajdonságokat tárolja. Ebben a fejezetben ezt az
osztályt illetve a hozzá szorosan kapcsolódó kisebb struktúrákat fogjuk
bemutatni.

Az alakzat építéséhez tartozó kisebb struktúrák egyenként megfelelnek az API
szinten hívható path építő függvények valamelyikének. Vagyis a \func{moveTo}
híváshoz a \func{MoveToElement} struktúra tartozik és így tovább. A \func{Path}
osztályban minden elemhez tartozik egy függvény, amellyel ezekből a
struktúrákból adhatunk hozzá példányokat az épülő alakzathoz. Tehát a fenti
példában említett \func{moveTo} hatására a \func{Path}-beli \func{addMoveTo}
függvény hívódik, és hozzáad az alakzat építésének sorába egy példányt a
\func{MoveToElement} struktúrából. Természetesen nem minden alakzatépítő
híváshoz tartozik egyedi struktúra. Néhányat közülük visszavezethetünk egy vagy
több másikra. Ilyen például a \func{rect} API függvény, amit akár már a felső
rétegben is visszavezethetünk egy \func{moveTo} és három \func{lineTo} hívásra.
Vagy hasonló a \func{arcTo} API hívás. Ami ugyan meghívja a \func{Path} osztály
\func{addArcToElement} függvényét, ugyanakkor ez a függvény végül mégis csak
átalakítja ezt az elemet, és egy \func{LineToElement} valamint egy az
\func{arc} függvényhez tartozó \func{ArcElement} párosaként adja hozzá az
alakzatot leíró listához.

Minden speciális alakzatelemet definiáló struktúra egy közös ős
(\func{PathElement}) struktúrából származik. Tehát a megvalósított struktúrák a
következők:
  \begin{itemize}
    \item \func{PathElement} (ős),
    \item \func{MoveToElement},
    \item \func{LineToElement},
    \item \func{CloseSubpathElement},
    \item \func{QuadraticCurveToElement},
    \item \func{BezierCurveToElement},
    \item \func{ArcElement}.
  \end{itemize}
Nézzük meg részletesebben ezeket a struktúrákat.

A \func{PathElement} mint ős definiálja a közös információkat. Minden
alakzatelemnek van végpontja, ahol az alakzatot rajzoló képzeletbeli tollhegy
megáll. Ez egy koordinátát tároló \func{to} adattag. Minden alakzatelemre igaz,
hogy vagy az utolsó, vagy követi egy újabb elem. A \func{next} adattag adja meg
a következő elem memóriacímét. Amennyiben ez \func{NULL}, az azt jelenti, hogy
az adott elem az utolsó struktúrája az alakzatnak. Minden struktúrának meg kell
tudnia mondania magáról, hogy a speciálisak közül melyik. Erre akkor van
szükség, hogyha ősként hivatkoznánk rá. Ezt adja meg a \func{type} adattag.

A \func{MoveToElement} jelöli az alakzatépítési-listában, hogy felemeltük a
tollat, és áthelyeztük egy másik pontba. A \func{LineToElement} egy egyenes
vonalat határoz meg az utolsó elem végpontjától a saját végpontjáig. A
\func{CloseSubpathElement} egy egyenes vonallal zárja a legutolsó
\func{MoveToElement} pontjából indított alakzatot. Mindhárom struktúra csak
annyiban tér el az őstől, hogy markerként hordozza a típusát.

A \func{QuadaraticCurveToElement} egy másodrendű Bézier görbét határoz meg az
előző elem végpontjától a saját végpontjáig az újabb adattagként megjelenő
kontrollpont szerint. A \func{BezierCurveToElement} egy harmadrendű
Bézier görbét határoz meg az előző elem végpontjától a saját végpontjáig a két
újabb adattagként megjelenő kontrollpontok szerint.

Az \func{ArcElement} struktúra leír egy körcikket. Ez a struktúra több
adattaggal is bővül az őshöz képest. Egyrészt tárolni kell a középpontot, a kör
sugarát, a körcikk kezdő és vég szögét, valamint a körbejárás irányát. Ezen
kívül még tárolni kell egy transzformációt. Erre a transzformációra azért van
szükség, hogy a kirajzolás pillanatában pontosan ismerhessük az alakzat
torzulását. Hiszen az alakzat építése közben több halmozott transzformáción is
áteshet egy ilyen elem. Ezeket a transzformációkat az építés közben
összegyűjtjük, és a megfelelő rajzoló parancs hívásakor alkalmazzuk erre az
alakzatelemre, biztosítva azt, hogy nem halmozunk fel torzulási hibákat a
transzformációk során. Itt kell még megjegyeznünk, hogy a sugarat is két
egymásra merőleges értékként tároljuk, hogy a \emph{nyírás} transzformációt jól
kezelhessük.

Az elemeket jelölő és azok adatait tároló segédstruktúrák után rátérhetünk a
\func{Path} osztályra. Ez az osztály az előbb felsorolt struktúrákat egy
listában tárolja. A lista első eleme a szabvány
értelmében\footnote{szabványrész} mindig egy \func{MoveToElement} kell legyen.
Utána pedig tetszőlegesen sok elem következhet. Jellemzően az alakzatokat
egymás utáni hívások sorozataként építjük fel. Ebből az is következik, hogy jó
pár viszonylag hasonló méretű struktúra memóriába való lefoglalására kerül sor
egy alakzat építésekor. Ugyanakkor érdemes kerülni az ilyen jellegű
foglalásokat. Ezért egy ún. \emph{Region} modellt alkalmaztunk a lista
tárolására.

Ez az osztály (\func{Region}) a tárolni kívánt struktúrák méretéhez képest
néhány nagyságrenddel nagyobb memóriaterületet (memóriarégiót) foglal le. A
struktúrákat pedig ebben a memóriarégióban listában tárolja úgy, hogy közvetlen
hozzáfér a már lefoglalt memóriához. Amennyiben az aktuális lefoglalt részből
kilógna a következő struktúra mérete, akkor a \func{Region} osztály újabb
szabad területet foglal le. Ez pedig már valóban memóriafoglalást eredményez,
ugyanakkor a nagyságrend függvényében jóval kevesebbszer. A modell másik nagy
előnye, hogy az eldobott alakzat memóriahasználatának felszabadítása is sokkal
kevesebb hívásból valósulhat meg. Jelenleg a lefoglalt memóriarégiók mérete
egységesen 2048 bájt, és előre eldöntött, azaz nem változik. Természetesen a
jövőben, a Gepard optimalizálásának fázisában akár dinamikusan változó méretű
memóriarégiók is használhatók; persze ha ennek hasznosságát mérések is
alátámasztják.

Most pedig nézzük át a \func{Path} osztályhoz tartozó függvényeket
(\emph{\ref{dataflow-path}. ábra}). Vannak egyrészt az elemeket
hozzáadó, illetve a már hozzáadott elemek bejárását és átalakítását biztosító
függvények.

  \begin{wrapfigure}{\melyikoldalra}{0.4\textwidth}
    \begin{center}
      \includedataflowkivagas{153pt}{355pt}{345pt}{595pt}{}
    \end{center}
    \caption{\label{dataflow-path} A belső Path API részei. \\ (Részlet a
    \emph{\ref{dataflow}. folyamatábrából}.)}
  \end{wrapfigure}

Az átalakításra azért van szükség, mert az alakzat építése közben lehetőség van
transzformációk alkalmazására, amiket az alakzatnak követnie kell. Erre szolgál
az \func{applayTransform} függvény. Gyakorlatilag a kapott
affin-transzformációval végig szorozza az addig felépített alakzat eleminek
meghatározó koordinátáit.

A bejárás lehetőségét pedig a \func{firstElement} függvény biztosítja.
Visszaadja a lista első elemének memóriacímét, amitől kezdve végig sétálhatunk
a struktúrákat tartalmazó listán. Az \func{isEmpthy} függvénnyel
lekérdezhetjük, hogy üres-e az alakzatot leíró lista. A \func{lastElement}
pedig megadja az utolsó elem memóriacímét a listában.

A már ismertetett struktúrákhoz rendre tartozik egy \func{Path} osztálybeli
függvény ami egy példányt ad a listához. Ezek a függvények bizonyos
feltételeket megvizsgálva és a szabványhoz igazodva alkalmaznak bizonyos
egyszerűsítéseket.

Az \func{addMoveToElement} függvény adja hozzá a képzeletbeli toll áthelyezését
leíró \func{MoveToElement} struktúrát. Az előírás szerint minden alakzat egy
ilyen elemmel kell kezdődjön. Ezért ez a függvény megvizsgálja, hogy az
alakzatot leíró elemek listája üres-e. Ha üres, akkor a megadott koordinátával
létrehoz egy ilyen elemet, beteszi a listába, és a listát leíró speciális
markereket (\func{firstElement}, \func{lastElement}) beállítja erre az elem
memóriacímére. Ha nem üres, és az utolsó elem a listában egy hasonló
\func{MoveToElement}, akkor értelemszerűen elégséges ennek az utolsó elemnek a
koordinátát tartalmazó adattagját módosítani az új elem értékeivel.

Az \func{addLineToElement} függvény egy egyenes vonal elemet ad a listához.
Vizsgálnia kell, hogyha még nincs elem a listában, akkor úgy kell viselkednie,
mintha egy \func{addMoveToElement} hívás történt volna. Vagyis az elem által
meghatározott (végpont) koordináta lesz az első pont. Ha nem üres a lista, és a
hozzáadni kívánt elem végpontja megegyezik az utolsó elem végpontjával, azaz
egy nulla hosszúságú vonalat kéne hozzáadni, akkor azt figyelmen kívül lehet
hagyni. Minden más esetben egy újabb \func{LineToElement}-et adunk a listához.

Az \func{addCloseSubpathElement} függvény egy alakzatot bezáró elemet ad hozzá
az listához. Ha a lista üres a függvény hívásakor, vagy az utolsó elem szintén
egy alakzatzáró, akkor a függvény mellőzi a beszúrást. A beszúrás minden
esetben egy egyenes vonalat jelent a lista legutolsó elemének végpontjától a
listában szereplő legutolsó \func{MoveToElement} pontjáig. Hogy mégis külön
struktúraként, azaz elemként kerül a listába, annak a körvonal funkcionalitása
az oka. Vagyis meg kell tudni különböztetni, hogy az adott alakzat zárt-e vagy
sem. Ami a kitöltés estében sosem kérdés, de a körvonal megrajzolásakor
kulcsfontosságú. Még akkor is fontos lehet ezt az elemet a listába szúrni, ha
az alakzat első és az utolsó pontja pont egybeesik. Ugyanis a körvonalak
végénél és a csatlakozási pontokban definiált lekerekítési stílusok
eltérhetnek, vagyis más eredményt kaphatunk a kezdő pontba húzott vagy ott be
is zárt path esetén.

Az \func{addQuadaraticCurveToElement} függvény egy másodrendű Bézier görbe
elemet add a listához. Ha a lista üres, akkor a görbe végpontját kezdő pontnak
kell tekinteni. Illetve egyszerűsítés az is, hogy ha a kontrollpont és a
végpont azonos, akkor az alakzatelem egy egyenes vonalra egyszerűsödik.

Az \func{addBezierCurveToElement} függvény egy harmadrendű Bézier görbe elemet
add a listához. Ha a lista üres, akkor a görbe végpontját kezdő pontnak kell
tekinteni.

Az \func{addArcElement} függvény egy körcikk elemet ad az alakzatot leíró
listához. Ha a lista üres, akkor kezdőpontnak a kör középpontját meghatározó
koordinátát kell választani. Ha a körcikk elfajuló, azaz nulla a sugara, vagy a
kezdő- és végszöge azonos, akkor csak egy egyenes vonalat kell húzni a kezdő
pontba, amit a kezdő szög határoz meg. Ha az utolsó elem koordinátája nem
egyenlő a körcikk kezdő pontjával, akkor szintén egyenes vonalat kell húzni a
kezdő pontba, de értelemszerűen az alakzatot leíró elemet már a listába kell
szúrni. A körcikk esetén még kisebb, a szögekkel kapcsolatos egyszerűsítéseket
lehet alkalmazni.

Az \func{addArcToElement} függvény elméletileg egy speciális körcikk elemet ad
a listához, valójában azonban ehhez a függvényhez nem tartozik külön struktúra.
Itt azért nem volt szükség külön struktúrára, mert ez a függvény által leírt
elem megadható egy egyenes vonal és egy körcikk segítségével. Ezért ez a
függvény ezt a visszavezetést tartalmazza. Arról már volt szó~\footnote{TODO:
ellenőrizni}, hogy ehhez a függvényhez egy olyan alakzatelem tartozik, ami
főleg a lekerekített alakzatok könnyebb meghatározását biztosítja. Például egy
rádiusz érték következetes használatával könnyedén definiálhatunk egy, a
sarkainál lekerekített téglalapot. Ha most ezt a téglalapot vesszük, akkor négy
ilyen alakzatelemből felépíthetjük. Ugyanakkor a valóságban négy egyenes
vonalból és négy körcikkből épül fel. Ennél az elemnél tudjuk, hogy mindig
benne van a használt pontok által meghatározott alakzatban, csupán a sarkoknál
a megadott rádiusz(ok) hatására körcikkeket kell beszúrjunk. A visszavezetés
azt kell eldöntse, hogy milyen szögtől milyen szögig terjed a körcikk, és az
előző elem végpontjából hogyan kell vonalat húzni a lekerekítést adó
körcikkhez.

    \subsection[A körvonal rajzolása]{A körvonal rajzolása}

A körvonal visszavezetését egy külön osztály (\func{StrokePathBuilder}) kezeli,
mégis a \func{Path} osztály leírásának részeként mutatjuk be. Ugyanis magának a
visszavezetést kezelő osztálynak szerkezete igen hasonló \func{Path}-éra. A
kitöltéskor egyszerűen bejárjuk az elemeket tartalmazó listát, és a
későbbiekben ismertetett módon trapézokká (végül is háromszögekké) alakítjuk az
alakzatot. A körvonal esetében egy köztes lépést alkalmazunk. Egy path
körvonala felfogható egy adott vastagságú vonalakból álló, bonyolultabb alakzat
kitöltésével. Magyarán, az eredeti path-ból képezünk egy olyan újabb
alakzatot, aminek a kitöltése az eredeti path körvonalát adja. Ezt az újabb
alakzatot továbbra is a \func{Path} osztállyal határozzuk meg. Ezért is tartjuk
indokoltnak, hogy ehhez az alfejezethez tartozóan beszéljünk róla.

Tehát a körvonal kirajzolását indukáló hívás (\emph{stroke}) hatására először a
visszavezetés történik meg. Az így kapott alakzat úgy áll elő, mint az eredeti
path vastagságát megadó \func{lineWidth} attribútum különálló részalakzatai.
Például a \func{LineToElement} elem egy téglalap alakzatként kerül az új
path-ba. Nézzük meg nagy vonalakban az egyes elemek alakzatait, illetve a
csatlakozási- és végpontoknál használt formákat.

Egy vonalat leíró elem esetén elméletileg úgy kell eljárni, hogy a vonalelemre
merőlegesen egy szakaszt helyezünk a középpontjával. A szakasz hossza a
megadott vastagsággal egyenlő. Majd a vonal mentén végigsöprünk az adott
elemen, tartva minden pontban a merőlegességet. A vásznon érintett pontok
tartoznak az adott körvonalelemhez. A gyakorlatban ez olyan három- és
négyszögek hozzáadását jelenti, amik az adott felbontás mellett lefedik az
elméleti alakzatelemet.  Például az egyenes vonalelem esetén egy azzal
párhuzamos téglalapot kell hozzáadnunk úgy, hogy a téglalap vastagsága
értelemszerűen a megadott értékkel egyenlő, hossza a vonaléval egyenlő, és a
téglalapot megadó vonalra úgy illeszkedik, hogy a vonal hosszmentén felezi a
téglalapot.

A toll áthelyezését jelölő \func{MoveToElement}-nél ugyan nem kell különálló
formát hozzáadnunk az új alakzathoz, de lehetséges, hogy kiegészítő formákat
mégis be kell szúrjunk. Ilyen kiegészítő formák lehetnek a path végeinél a
\emph{lezárások} (\inenglish{cap}) és/vagy a köztes elemek közötti
\emph{csatlakozási pontok} (\inenglish{join}).

Az eredeti path elemeinek végpontjában (az elemek sajátosságai miatt) mindig
értelmezhetünk egy párhuzamos vektort. Egy kezdő- vagy végelem esetén
lehetséges, hogy záróformát kell illesszünk az adott elemhez. Ha kell, akkor ez
egy a vastagságot kipótoló \emph{téglalap} (\inenglish{square}) vagy egy abba
illeszkedő \emph{félkör} (\inenglish{round}) lesz, különben \emph{csonk}
(\inenglish{butt}) formán hagyjuk. Ezeknek a kiegészítő formáknak az
irányultságát határozzák meg az adott pontban ismert vektorok.

Két vonal csatlakozásakor úgy kell eljárni, hogy a hézagokat töltsük fel a
meghatározott módon. Egy háromszög forma \emph{simán} (\inenglish{bevel})
összekapcsolja a két elem végét. Ha pedig szükséges, akkor egy újabb háromszög
\emph{süvegesre} (\inenglish{miter}), vagy egy körcikk \emph{lekerekítettre}
(\inenglish{round}) egészíti ki az összekapcsolás pontját.

Tehát az egyenes vonalakat téglalappal helyettesítjük. A körcikk esetén úgy
járunk el, hogy egy fél vonalvastagsággal kisebb és egy ugyanennyivel nagyobb
körcikket a végeiknél összekötünk. Természetesen a szabványban leírt esetleges
összekötő egyenes vonalat itt is hozzá kell adni, ha szükséges.

A Bézier görbék esete egy parányit bonyolultabb. Hiszen itt nem járhatunk el az
előzőekben említett fél vastagsággal történő kibővítéssel. Egészen más görbét
jelent az adott vonalvastagságú Bézier görbe ,,belső'' és ,,külső'' ívét leíró
görbe. Éppen ezért itt úgy járunk el, hogy a vastagság definícióját alkalmazzuk
egy adott megközelítéssel. Itt is kihasználjuk a de Casteljau algoritmus
nyújtotta gyors Bézier görbe feloszthatóságot. Az alap Bézier görbe mentén
haladunk, és elfelezzük, majd ezt mindaddig, amíg az egyik oldalára nem lesz
igaz, hogy egy határértéken belüli állapotba értünk. Az oldal itt a görbe
,,sebességvektorának'' a normáltja szerinti ,,pozitív'' vagy ,,negatív''
félsíkot jelenti. A határérték pedig azt jelenti, hogy a görbe egyik oldalára
eső részt egy négyszöggel már elégséges pontossággal meg lehet közelíteni.
Ekkor úgy vesszük, hogy ez a négyszög a görbedarabot lefedi. Ha szükséges a
másik oldal miatt, akkor a görbét tovább osztjuk, de a már előzőleg lefedett
oldallal már nem foglalkozunk. Gyakorlatilag a végső görbe képe ilyen
összekapcsolt négyszögekből fog állni. Sajnos bizonyos elfajuló esetekben ez
vagy nagyon sok darabkát jelent, vagy nem is egyértelmű, hogy hogyan kellene
eljárjon az algoritmus. Ezek az esetek szerencsénkre azért felismerhetők, és
mint speciális esetek egyike kezelhetőek. Ilyen elfajuló eset pl. ha a
harmadrendű görbe a közepénél ,,megtörik''. Ilyenkor egy egészen kis
tartományban olyan gyorsan változik a derivált, hogy nem is biztos, hogy
folytonos módon követni tudjuk. Ha ilyen eset megközelítő képét tapasztaljuk,
akkor a megközelített ,,törési'' pontban elhelyezünk egy kört, aminek az
átmérője pont a vonalvastagság. Így ugyan lesznek többszörösen lefedett részek,
ugyanakkor az alakzat képe a definíció szerintit követi, vagyis a ,,külső'' ív
szépen körbefordul a ,,törési'' pont körül.

A körvonal visszavezetésénél a kitöltendő alakzatot mindig a \emph{nem-zérus}
szabállyal rendereljük. Erre többek között az előbb is bemutatott elfajuló
esetekből fakadó esetlegesen egymásra kerülő darabkák miatt van szükség. Így
nem keletkezhet lyuk az alakzat képében. Máskülönben a visszavezetett
alakzattal pontosan úgy járunk el mint egy egyszerű kitöltendő párjával.

  \section{Szakaszra bontás}

A felépített alakzatot fel kell bontanunk, hogy kirajzolhassuk. A több
lehetséges módszer közül mi a trapézokká alakítást választottuk. Ahhoz azonban,
hogy az alakzatot lefedő trapézokat megadhassuk, előbb az alakzatot megközelítő
szakaszokra bontjuk a path-t. Ezt a lépést valósítja meg a
\func{SegmentApproximator} osztály. Az osztály -- mint arról nár volt szó --
effektív a \emph{köztes réteghez} tartozik. Hiszen ezt a modellt bármelyik
rajzoló egység használhatja. Ugyanakkor jelenleg csak a GLES2-es rajzoló egység
használja.

Az osztály API-t és a függvényeket részletesen nem tárgyaljuk. Inkább a
megvalósításra, mint egészre koncentrálunk. Természetesen bizonyos fontosabb
részeket pontosan átnézünk.

A path kirajzolását indukáló függvények egyikének hatására a
\func{TrapezoidTessellator} osztály \func{trapezoidList} függvénye (lásd
később) bejárja az alakzatot, és első körben a \func{SegmentApproximator}
segítségével felbontja azt. A felbontás lépései a következők.
  \begin{enumerate}
    \item Az alakzatot leíró lista bejárása, és az elemekhez tartózó
    \emph{szakaszra bontó függvények} meghívása.
    \item Szakaszok beszúrása egy speciális struktúrába (\func{SegmentTree}).
    \item A struktúrában az érintett szakaszok kettévágása a metszéspontok
    mentén.
    \item A már nem metsző szakaszok rendezése.
  \end{enumerate}
Nézzük meg részletesebben ezeket a lépéseket.

A path bejárása effektív a \func{TrapezoidTessellator} osztályban történik,
ugyanakkor ez mind a \func{SegmentApproximator} osztály hívásait és a
szakaszokat tároló struktúráit érinti. Az alakzat bejárásakor érvényesíteni
kell az aktuális állapothoz tartozó transzformációt. Ezt a legészszerűbb ebben
a lépésben megtenni. Hiszen később a metszések révén sokkal több pontot kellene
bejárni ugyanezért. A transzformációk érvényesítése után az egyes elemek
szerint meghívjuk a \func{SegmentApproximator} megfelelő függvényét. Az egyenes
vonal esetén ez egy megfelelő szakasz beszúrását jelenti. Ekkor a szakaszokat
megfelelő módon tároló \func{SegmentTree}\footnote{Ez egy \func{std::map<const
int, SegmentList*>} struktúra.} struktúrában két új bejegyzés jön létre.
Először a szakasz kezdő- és végkoordináták $y$ értékének megfelelően két új
üres \func{SegmentList} lista jön létre, ha még nincs ilyen az adott $y$
bármelyikére. Ezután a kisebbik $y$-hoz tartozó listába kerül egy új
\func{Segment} struktúra, ami leírja az adott szakasz értékeit és irányát. A
következő hasonló szakasz beszúrása esetén hasonlóan kell eljárni. Világos,
hogy így egy szakaszokat (\func{Segment}) tartalmazó listák egy $y$-ok szerint
rendezett listáját, leképezését kapjuk. Ekkor még a szakaszok se nem
rendezettek, és nem vizsgáltak a metszéspontok sem.

  \begin{wrapfigure}{\melyikoldalra}{0.4\textwidth}
    \begin{center}
      \includedataflowkivagas{345pt}{400pt}{525pt}{590pt}{}
    \end{center}
    \caption{\label{dataflow-segment} A szakasszá alakítás és a megközelítő
    visszavezetések. \\ (Részlet a \emph{\ref{dataflow}.
    folyamatábrából}.)}
  \end{wrapfigure}

Ha nem egy egyenes vonalat kell beszúrni, hanem egy bonyolultabb görbe vonalat,
akkor kerülnek képbe \aref{Háttér}. fejezetben tárgyalt matematikai
visszavezetések.

Egy Bézier görbe esetében ez a következőket jelenti. A görbét az
\func{insertBezierCurve} függvény fogja feldarabolni, és a megközelítési
kritériumnak megfelelő görbedarabokat szakaszokként a struktúrához adni. Az
algoritmus logikája azonos mindkét rendű Bézier görbénél.

A metódus a görbefelosztás mentén rekurzív. De ezt bizonyos mélységig egy $16$
görbe leírásának megfelelő méretű veremmel szimuláljuk. A görbék felbontását
\aref{eq:1} képletnek megfelelően mindig a $t=\frac{1}{2}$ pontban hajtjuk
végre. Nézzük meg az egyes lépéseket.
  \begin{enumerate}
    \item Lefoglalunk egy $16$ görbének elegendő puffert (\emph{verem}).
    \item A kapott görbét a verembe tesszük.
    \item Kivesszük a legfelső görbedarabot, és megvizsgáljuk, hogy leírható-e
    szakaszként.
    \begin{description}[topsep=0ex]
      \item[Ha igen] A görbedarabot a végpontjait összekötő szakaszként
      beszúrjuk a \func{SegmentTree} struktúrába, és folytatjuk a $3$-as
      ponttal.
      \item[Különben] A görbét a $t=\frac{1}{2}$ pontban kettévágjuk, és
      a két görbedarabot a verembe tesszük.
    \end{description}
    \item Megvizsgáljuk, hogy betelt-e a verem.
    \begin{description}[topsep=0ex,noitemsep]
      \item[Ha igen] A görbedarabbal újrakezdjük az $1$-es pontban. (Rekurzív
      rész. Ritkán hívódik.\footnote{TODO: Mérés})
      \item[Különben] Folytatjuk a $3$-as ponttal.
    \end{description}
  \end{enumerate}

A felbontás mértékét két tényező befolyásolja. Az egyik egy \emph{tolerancia
érték}. Azt fejezi ki, hogy mi az az érték, ami alatti különbséget már nem
tekintjük mérvadónak. Ez az érték jelenleg $1$, ami egy raszterpont méretének
felel meg. A másik tényező az \emph{élsimítás} (\inenglish{anti-aliasing})
mértékét kifejező szám. Ez a szám jelenleg $16$, ami azt jelenti, hogy a
raszterpontok méretéhez képest egy tizenhatoddal kisebb értéket tekintünk
raszterpontnak, és ezt \emph{alpixelnek} (\inenglish{subpixel}) hívjuk. Erre a
felbontásra azért van szükség, hogy információnk legyen arról, hogy az alakzat
nagyjából hány százalékát takarja ki a valódi raszterpontnak. Ha egy félig
kitakart raszterpontot nem gyújtunk ki teljesen, hanem csak fél intenzitással,
akkor a kapott alakzat élei kevésbé lesznek ,,szálkásak''. A használt
színcsatornák méretei egy-egy bájt ($8$ bit). Ami azt jelenti, hogy az
intenzitás mértéke 256 különböző értéket vehet fel. Ez egy $16\times16$-os
felbontást tesz lehetővé, vagyis ez indokolja az élsimítás mértékét.
Természetesen ennél kisebb érték is választható, és persze nagyobb is, bár ez
utóbbinak nem sok értelme van a jelenlegi színcsatorna-méretek tükrében.

Az élsimítás és a tolerancia mértéke nem csak a felbontásokra van hatással. Az
egymást metsző szakaszok esetében is figyelembe kell venni. Erről majd később
még lesz szó.

A másik nem egyenes vonal a körív. Mint arról már volt szó, a köríveket Bézier
görbékkel közelítjük. \Aref{arctobezier}. alfejezetben bemutatott matematikai
módszert követve osztjuk a körcikket harmadrendű görbékre. A felosztás menete a
következő. Miután alkalmaztuk a körcikkre az aktuális transzformációt, meg kell
határozni a körcikk kezdő- és végpontját. Ha szükséges, akkor az utolsó végpont
és a körcikk kezdőpontja közé egy szakaszt szúrunk be, biztosítva az alakzat
folytonosságát. Az világos, hogy a transzformációk révén a körcikkünk akár egy
ellipszis-cikk formájába is átmehet. Az ismertetett matematikai képletek
ugyanakkor körre értelmezettek. A Bézier görbék affin invarianciája miatt ez a
megközelítést nem módosítja. Ugyanakkor a megközelítés mértékét befolyásoló
sugár helyett az ellipszis két tengelye közül a nagyobbikat kell választanunk. A
tolerancia érték és a kapott nagytengely aránya határozza meg az $\epsilon$
értéket. Ennél az értéknél kell kisebb legyen \aref{eq:2} képletben kapott
$\epsilon_{max}$. Ez viszont a körcikk szögétől függ. Ha nem elég kicsi, akkor a
szöget elfelezzük, és megvizsgáljuk újra a különbséget, ha továbbra sem
elégséges, akkor addig ismételjük, amíg nem lesz igaz, hogy $\epsilon_{max} <
\epsilon$. Ezzel pedig megkapjuk, hogy hány darabra kell osztanunk az eredeti
körcikket. Ha $k$ részre osztjuk az $\alpha$ szögű körcikket, akkor egy darabkát
megközelítő Bézier görbe adatait a $h_1 = \frac{4}{3} \tan{\frac{1}{4} \beta}$
értékkel megadhatjuk, ahol $\beta = \frac{\alpha}{k}$. A görbéket pedig az
előzőekben ismertetett függvény hívásával tovább bontjuk, így megkapjuk a
körcikk (vagy ellipsziscikk) szakaszokból álló képét.

  \begin{figure}
    \centering \includegraphics[width=.9\textwidth, viewport=0pt 60pt 300pt
    160pt,clip]{img/built/sunmoon_eps}
    \caption{\label{sunmoon} Beszúrt
    szakaszok $(S_i)$ és azokat tartalmazó listák $(L_j)$. A \emph{csillag}
    formánál két szakasz $(S_1$ és $S_2)$ metszéspontja által létrehozott új
    listára $(L_m)$ láthatunk példát. Az $S_1$ és $S_2$ szakaszok
    lerövidülnek, maradék részüket már az $S_m^1$ és $S_m^2$ szakaszok
    tartalmazzák. A \emph{hold} formánál pedig egy szakasz $(S_5)$
    végpontja által definiált lista $(L_1)$ miatt az $S_4$ szakaszt is fel
    kell bontani.}
  \end{figure}

Az alakzat elemeinek a felbontása után a szakaszokat kell felbontanunk. Egyrészt
minden szakaszt felbontunk ha szükséges a különböző $L_i$ listákhoz tartozó
$y_i$ értékek mentén (lásd a \emph{\ref{sunmoon}. ábrát}). Másrészt a szakaszok
egymást metsző pontjait kell megtaláljuk (lásd szintén a \emph{\ref{sunmoon}.
ábrát}).

A szakaszok felbontásához bejárjuk az $y$ koordináta mentén létrehozott
listákat. Kezdve a két legkisebb $y_0$ (ahol a lista legyen az $L_0$) és $y_1$
($L_1$) értéknél. A legkisebb $y_0$-hoz tartozó $L_0$ (\func{SegmenList})
elemein végigmegyünk. Ezek az elemek szakaszok (\func{Segment}), és igaz rájuk,
hogy vagy a következő legkisebb $y_1$ vagy egy további $y_i$ ($y_i > y_1$)
értékig nyúlnak. Ha az $L_0$ listában egy $y_1$-en túllógó elemhez érünk, azt
kettévágjuk az $y_1$ mentén. Az előző elemmel egybevágó két új elemet úgy
állítjuk elő, hogy az eredeti elemet $y_1$-ig rövidítjük, majd a maradék
résznek megfelelően egy új elemet szúrunk az $L_1$ listába. Az aktuális lista
(a példában $L_0$) elemeinek bejárásakor vizsgáljuk, hogy metszik-e egymást. Ha
találunk metszéspontot, akkor annak $y_m$ értékéhez beszúrunk egy újabb listát,
majd az egész folyamatot újra kezdjük az aktuális listán ($L_0$).

Szabnunk kellett egy alsó határt a felbontás pontosságának. Erre azért volt
szükség, hogy a listák bizonyos $y$ környékén ne sűrűsödjenek be. Vagyis
egyfajta megálljt kell parancsolnunk egy bizonyos érték alatt. Ez az érték
természetszerűleg adódik a már említett élsimítás és felbontási faktorok
mértékéből. Az élsimítás szempontjából sem értékelhető közelségű $y$ értékeket
egy előre kiválasztott kerekítési szabállyal azonosnak tekintjük.

Legyen $y_t$ érték, amihez tartozhat lista. A következő érték amihez tartozhat
lista az az $y_b = y_t + m$, ahol $m$ egyenlő a fentebb definiált
\emph{alpixel} magasságával, és igaz, hogy $y_t~\equiv~0~\pmod{m}$. Hasonlóan
értelmezzük a szomszédos $x_l$ és $x_r$ értékeket is úgy, hogy szintén igaz,
hogy $x_r - x_l = m$ és $x_l~\equiv~0~\pmod{m}$. Magyarán, ez egy alpixelek
által meghatározott rácsot jelent úgy, hogy a rács egyik pontja egybevág a $(0,
0)$ ponttal. Világos, hogy a fenti megkötések észszerűek. Ugyanakkor sok
metszéspontra lesz igaz, hogy nem esik majd rács vízszintes vonalaira. Az ilyen
metszéspontokat el kell tolnunk a legközelebb eső kisebb $x_l$ és $y_t$ pontba.
Vagyis, ha egy metszéspont egy alpixel belsejébe esik, akkor azt elmozgatjuk az
alpixel bal felső sarkába. Az elmozgatás révén az ebbe a pontba futó szakaszok
leírását is módosítani kell, valamint az innen kifutó szakaszokat is ezen új
értékek mentén kell meghatározni. Bár ez geometriai torzulást jelent ugyan,
viszont a torzulás mértéke a valódi raszterponton belüli, vagyis annyira kicsi,
hogy tulajdonképpen észrevehetetlen.

Eddig kevés szó esett a szakaszokat tároló adatszerkezetről. Nézzük meg ezt is
részletesebben. Arról már volt szó, hogy a szakaszokat lista, a listákat pedig
a \func{SegmentTree} struktúra tárolja. A jelen megvalósítás nem a
legoptimálisabb adatszerkezet. A dolgozat szempontjából a pontos és helyes
működés elsődleges cél volt. A könnyebb hibakereséshez első körben nem
bonyolítottuk, illetve optimalizáltuk ki a tároló adatszerkezetet. A listákat
tároló \func{SegmentTree} egy \func{std::map<const int, SegmentList*>}
adatszerkezet. Ahol a \emph{kulcs} az előbb említett alpixel rács $y$ értékei
egészre kerekítve (\func{trunc}). Az \func{std::map} mögött egy piros-fekete fa
implementáció található\footnote{
\footnotesize{\url{https://en.cppreference.com/w/cpp/container/map}}}. Az
\emph{érték} mezőben pedig egy láncolt lista memóriacímét tároljuk. Ez a
\func{SegmentList} egy \func{std::list<Segment>} típusú lista, ami a szakaszok
leírását megvalósító \func{Segment} osztály példányait tárolja. A jelen
megvalósításban akár többször is szükséges ezeknek a listáknak a rendezése, így
egészen biztosan nem a legoptimálisabb a jelenlegi adatszerkezet. Ugyanakkor
egyszerű, és pontos. A hibakeresést egyszerűsíti, és az általa tárolt
szakaszokból renderelt kép jó referencia lehet a jövőbeli optimalizálások
során. A későbbi javítások során fontos szempont lehet, hogy az adatszerkezetet
,,csak'' bővítjük. Azaz beszúrást hajtunk csak végre. Ez igaz mind a listák,
mind pedig a szakaszok tekintetében is. Vagyis egy olyan folyamatosan rendben
tartott adatszerkezet lehet az optimális, ami egyrészt megtartja a geometriai
rendezettséget és leírást a szakaszok között, ugyanakkor gyorsan tud
szakaszokat beszúrni.

Fontos még megnézni, hogy mit jelent a jól rendezettség ebben az esetben.
Ahhoz, hogy később trapézokká alakíthassuk a szakaszok által határolt
területet, pontosan tudnunk kell, hogy melyik szakasz van előbb a sorban. Tehát
a szakaszok rendezettek a következőképpen:
  \begin{enumerate}
    \item a szakaszokat tároló listák az $y$ értékek szerint szigorúan
    növekvő módon rendezettek,
    \item a listában a szakaszok a kisebb $y$ értékhez tartozó $x$
    értékek mentén növekvő sorrendben rendezettek,
    \item az azonos $(x, y)$ pontból kiinduló szakaszok keresztszorzata
    szerint növekvő sorrendben rendezettek; azaz rendezettek, ha a
    keresztszorzat nem negatív,
    \item ha a keresztszorzat zérus, akkor megtartjuk a beszúrás sorrendjét.
  \end{enumerate}

Az $y$ értékek mentén felosztott és a fentiekben előírt módon rendezett
szakaszokat már könnyedén trapézokká alakíthatjuk.

  \section{Trapézzá alakítás}

Az előző fejezetben bemutattuk, hogy hogyan kapjuk meg az alakzatunk
szakaszokból megközelített képét. Azt is láthattuk, hogy nem csak az alakzatot
bontottuk fel szakaszokra, hanem magukat a szakaszokat is felosztottuk az $y$
értékek mentén. Ennek a felosztásnak a célja az volt, hogy a szakaszokat
tartalmazó listákat bejárva, az eredeti alakzatot lefedő trapézokat
alakíthassunk ki. A trapézokra a renderelés során lesz szükségünk. Minden
trapéz leírható két háromszögként. Ezeket a háromszögeket tudjuk majd
kirajzolni.

  \begin{wrapfigure}{\melyikoldalra}{0.4\textwidth}
    \begin{center}
      \includedataflowkivagas{345pt}{200pt}{525pt}{393pt}{}
    \end{center}
    \caption{\label{dataflow-trapezoid} A trapézzá alakítás és
    összevonás lépései. \\ (Részlet a \emph{\ref{dataflow}. folyamatábrából}.)}
  \end{wrapfigure}

Nézzük meg részletesebben a trapézzá alakítás folyamatait. Három fontos lépést
különíthetünk el (lásd a \emph{\ref{dataflow-trapezoid}. ábrát}).
  \begin{enumerate}
    \item A szakaszokból a kitöltési stratégia (\emph{nem-zérus} vagy
    \emph{paritás} szabály) szerint trapézokat alakítunk ki (építünk).
    \item Ha lehetséges, a trapézokat horizontálisan összevonjuk.
    \item Ha lehetséges, a trapézokat vertikálisan is összevonjuk.
  \end{enumerate}
Bár külön pontként tüntettük fel az építést és a horizontális összevonást,
valójában ezt egyszerre hajtjuk végre.

Kezdjük a trapézok építésével. Az eljárás a következő. Bejárjuk a szakaszokat
tartalmazó listákat, kezdve az elsővel (legkisebb $y$ értékű). Vegyük az első
szakaszt a listában. A képzeletbeli pásztázó egyenesek elsőre ebbe a szakaszba
üköznének, vagyis a szakasz utáni területet renderelnünk kell majd. Ezért ez a
szakasz lesz az első trapéz bal szára. Ezután haladunk a következő szakaszra.
Ez a szakasz lehet a trapéz jobb szára, és így e két első szakasz adhatja ki az
első trapézt. A feltételes mód azért van, mert a kitöltési szabály és a két
szakasz geometriai viszonya még felülírhatja ezt. Ha a paritás szabály
érvényes, és a két szakasz nem esik egybe, akkor trapéz lesz belőle. Ha
egybeesik, akkor elvetjük a két szakaszt, és folytatjuk mintha nem is létezett
volna ez a két szakasz. Ha azonban a nem-zérus szabály van érvényben, akkor az
első és a második szakasz irányultságának viszonya határozza meg, hogy mi
történik. Ha ellentétes irányultságúak, és nem esnek egybe, akkor trapéz lesz
belőlük; ha egybeesnek (továbbra is ellentétes irányultsággal), akkor elvetjük
őket. Ha azonos irányultságúak, akkor marad továbbra is az első szakasz a
trapéz bal szára, és feljegyezzük egy változóba, hogy két azonos irányultságú
szakaszon vagyunk túl. Ezt mindaddig folytatjuk, amíg ez az érték nem csökken
zérusra. Ekkor az utolsó szakasz lesz a trapéz jobb szára. Az elkészült trapézt
egy listába tesszük. Majd haladunk tovább a következő szakaszra, mintha az
lenne az első, és így elölről kezdjük az említett eljárást.

  \begin{figure}
    \centering \includegraphics[width=.9\textwidth, viewport=0pt 60pt 300pt
    160pt,clip]{img/built/sunmoontrapezoids_eps}
    \caption{\label{sunmoontrapezoids} Az épített $(t_i)$ és az összevont végső
    $(T_j)$ trapézok. A sima $+$ jel a horizontális, a $\oplus$ jel a
    vertikális összevonásokat jelenti. Pl. a $T_5$ esetében jól látszik, hogy
    az $L_2$ és az $L_m^1$ listákhoz tartozó szakaszokból épített és
    vízszintesen összevont trapézokat később még vertikálisan is egyesítjük.}
  \end{figure}

Ha elkészül egy trapéz, és van már előző trapéz a listában, akkor
megvizsgáljuk, hogy összevonhatók-e. Ha az aktuális trapéz bal szára egybeesik
az utolsó trapéz jobb szárával, akkor az utolsó trapézt kibővítjük. Vagyis az
utolsó trapéz jobb szára az aktuális trapéz jobb szára lesz, és az aktuális
trapézt elvetjük.

Így haladunk szakaszról szakaszra és listáról listára. Itt is igaz, hogy a
feladat a jelenlegi megvalósításhoz képest optimalizálható. Mivel a mostani
implementáció egyszálú. Viszont a bejárás szempontjából az egyes listák
függetlenek egymástól, tehát akár egy \emph{termelő-fogyasztó}
(\inenglish{producer--consumer}) modellel is párhuzamosítható lehet a trapézok
építése és horizontális összevonása.

Az utolsó lépés a vertikális összevonás vizsgálata. A már horizontálisan
összevont trapézok listáján újra végig haladunk. Vegyük az első trapézt, és
vizsgáljuk meg, hogy a rákövetkező $y$ értékhez tartozó trapézok közül van-e
olyan, hogy azzal összevonható lenne. Az összevonás értelemszerűen azt jelenti,
hogy az új trapéz a két egyesítettet pontosan lefedi. Ehhez az kell, hogy a
,,felső'' trapéz alsó alapvonala egybeessen az ,,alsó'' trapéz felső
alapvonalával, és a bal, illetve a jobb szárak meredeksége megegyezzen. Ekkor a
felső (sorban hamarabb szereplő) trapéz adatait úgy módosítjuk, hogy kiadja az
egyesítettet, az alsó trapézt pedig elvetjük.

Emlékezzünk vissza, hogy a metszéspontok kalkulációjánál megtörténhetett, hogy
a szakaszok végpontjait enyhén eltoltuk, ami miatt az érintett szakaszok
meredeksége megváltozott. Így geometriailag valaha összetartozó szakaszok
látszólag végleg szétváltak. Viszont az adott eltolás csak az adatszerkezet és
a listák túlburjánzásának elkerülése miatt volt szükséges. Ennél a pontnál akár
ki is javíthatnánk ezeket a kis változtatásokat. A szakaszra bontást leíró
részben ugyan nem említettük, de a szakaszokat leíró \func{Segment} osztály nem
csak a legszükségesebb koordinátaadatokat tárolja. Megjegyzi az egyes szakaszok
eredeti meredekségét, illetve egy egyedi azonosítóval is ellátja a szakaszokat.
Ezeket a másodlagos adatokat aztán a szakasz feldarabolásakor minden darabka
megőrzi. Világos, hogy a trapézok függőleges egyesítésének lépésében pontosan
ezeket az értékeket tudjuk felhasználni, hogy egy-egy szakaszról (még
pontosabban trapézszárról) eldönthessük, hogy valaha egy geometriai elem részei
voltak. Tehát ha az egyesítés csak a meredekség enyhe változása miatt nem
lehetséges, akkor ezt feloldhatjuk, és egyben még az előzőleg eszközölt kis
,,csalást'' is kijavítjuk. Természetesen az könnyen előállhat, hogy a
horizontális összevonás olyan ,,sikeres'' volt, hogy a vertikális összevonás
már nem lehetséges, viszont ennek a szűrése túl mutat ezen a viszonylag
egyszerű algoritmuson.

A szakaszra bontás, trapézzá alakítás és összevonás után birtokunkban van egy
trapézlista, ami lefedi az eredeti alakzatot. A következő lépés a grafikus
meghajtó felkészítése, beállítása és a trapézokból készített háromszögek
adatinak feltöltése, hogy végül kirenderelhessük az alakzatot.

  \section{Rajzolás GLES2-vel}

Az OpenGL~ES~2.0 működését \aref{GLES2:API}. alfejezetben már bemutattuk. Volt
arról szó, hogy milyen lépéseket kell megtennünk, és milyen lehetőségeink
vannak. Itt most a trapézok rendereléséhez szükséges beállításokat, és a
renderelést magát végző shader programokat mutatjuk be. Illetve szót ejtünk az
alakzat kiszínezéséről is. Ez ugyanis egy külön lépés; ennek okáról is
beszélünk majd.

Mielőtt azonban a trapézlisták kirajzolását mutatnánk be, előtte nézzük meg a
program betöltésekor szükséges iniciatív beállításokat és hívásokat.

Eddig arról nem volt szó, hogy mi biztosítja a kapcsolatot a programunk és az
ablakozást végző operációs rendszer, valamint magát a renderelést végző eszköz
között. Ha minden egyes beágyazott rendszeren a speciális programnak magának
kellene a kapcsolatot biztosítania, az igen bonyolult és nehezen támogatható
programot eredményezne. Ezért is alakult ki néhány olyan interfész, ami réteget
képez az eszköz, az eszközön futó operációs rendszer és az GLES2 API-t használó
program között. Az egyik ilyen elterjedt interfész az \emph{EGL}\footnote{Az
EGL szintén a Khronos Group által felügyelt platformfüggetlen API. \\ Forrás:
\footnotesize{\url{https://www.khronos.org/egl}}.}. Az EGL segítségével
adhatjuk meg, hogy pontosan milyen pufferbe akarunk rajzolni, annak a puffernek
mik a tulajdonságai (színcsatornák méretei, stb.), sőt az EGL-lel állítjuk be
magát a GLES2 API-t, vagyis a rajzolás kontextusát is. Az EGL tehát megteremti
a kapcsolatot a programunk és a valódi renderelést végző eszköz között
(természetesen az operációs rendszeren keresztül). Számunkra ami a
legfontosabb, hogy kapunk egy GLES2 kontextust, egy eredménypuffert és
szinkronizációt az ablakozó rendszerrel.

Az eddigi előrehaladó bemutatáshoz képest ezt a részt visszafelé bontjuk ki.
Vagyis majdnem az utolsó hívással, a renderelést kiváltó \func{glDrawElements}
függvénnyel kezdjük.

Ez a függvény feltölti a grafikus egységre a GLES2 beállításait és a bekötött
adatokat, illetve elindítja\footnote{Azt, hogy ténylegesen az adott függvénynél
indul-e el a renderelés, a GLES2 szabvány nem garantálja. Azt a grafikus
meghajtó gyártójára bízza.} a renderelést. A függvény három paramétert vár. Az
első, hogy a kirajzolandó elemeket hogyan kell értelmezni. A mi estünkben az
elemek független háromszögek csúcspontjai. Ezt a \func{GL\_TRIANGLES}
típusnévvel határozzuk meg. A második paraméter határozza meg az érintett
elemek számát. Ez háromszögenként három (vertex) elemet jelent, vagyis
trapézonként hatot. Az utolsó paraméter adja meg a GLES2 API-nak, hogy kisebb
(\func{GL\_UNSIGNED\_BYTE}) vagy nagyobb (\func{GL\_UNSIGNED\_SHORT}) méretű
indextömböt használunk-e. A trapézok lehetséges magas száma miatt mi rendre a
nagyobb méretűt választjuk majd.

Sok esetben az indextömböt a renderelés előtt állítjuk be. Ugyanakkor lehetőség
van egy általános indextömb korai feltöltésére is. Mivel mi mindig a nagyobb
tömbméretet választjuk, és a trapézokat -- még ha elfajulók is -- mindig azonos
módon bontjuk két háromszögre, ezért a program indulásakor -- az előbb említett
iniciatív részben már beállíthatjuk. Az indextömb első hat elem a következő:
$0, 1, 2, 2, 1, 3$. Ezek rendre egy-egy trapéz sarokindexei is: bal felső
($0$), bal alsó ($1$), jobb felső ($2$) és jobb alsó ($3$). Az indextömb
következő hat indexét pedig úgy generáljuk, hogy minden számhoz négyet
hozzáadunk. Majd a következő hatot is, és így tovább egy maximum $65536$
elemből álló tömbméretig. Ezt a tömböt feltöltjük a GPU memóriába, és
megjelöljük mint az általános indextömb. Az említett indexszámok jelentése
pedig értelemszerűen az egymást követő trapézokat lefedő két háromszög
csúcspontjait rendeli az adott trapéz sarkaihoz. Egy trapéz sarkához pedig
mindig tartozik valódi koordinátapár.

  \begin{figure}
    \centering
    \includegraphics[width=.9\textwidth, viewport=0pt 60pt 260pt
    150pt,clip]{img/built/sunmoonvertex_eps}
    \caption{\label{sunmoonvertex}}
  \end{figure}

Egy trapézt négy $x$ és két $y$ érték határoz meg: $\{x_{l,t}, x_{r,t},
x_{l,b}, x_{r,b}, y_{t}, y_{b}\}$\footnote{Ahol az indexben használt
rövidítések jelentése: $l=left, t=top, r=right, b=bottom$.}. Illetve az
előzőleg felsorolt sarokindexekhez ezekből négy koordinátapárt tudunk
összeválogatni: $i_0$ $(x_{l,t}, y_{t})$, $i_1$ $(x_{l,b}, y_{b})$, $i_2$
$(x_{r,t}, y_{t})$ és $i_3$ $(x_{r,b}, y_{b})$. Egy trapéz kirajzolása két
háromszög renderelését jelenti (lásd a \emph{\ref{sunmoonvertex}. ábrát}). Egy
háromszög renderelése három vertex (csúcspont) kiszámítását jelenti. Ezekre a
vertexekre fog lefutni a már említett vertex shaderből készített program.
Minden vertexre külön-külön (de párhuzamosan) lefut a vertex program úgy, hogy
a vertxehez speciálisan kap a program bemeneti adatokat. Egy vertexhez azonban
nem csak egy koordinátapár tartozik. Ennek az okára majd még visszatérünk.
Minden vertexhez át kell adnunk a teljes trapézt leíró hat értéket, és a
trapézon belüli sarokindexet. A bal felső sarok például a teljes trapézt leíró
hat értéket és a $0$-ás sarokindexet kapja meg. A bal alsó pedig szintén a
teljes trapéz leírást és az $1$-es sarokindexet, és így tovább. Amennyiben csak
simán a két háromszöget renderelnénk ki, nem volna szükség az összes adatra,
elég volna a vertexhez tartozó koordinátát átadni. Viszont a mi esetünkben az
élsimítást is a shader programokban számoljuk ki, ezért minden vertexnek tudnia
kell, hogy milyen a trapézhoz, és annak melyik sarkához tartozik.

Ezeket az adatokat egy ún. \emph{vertex attribútum tömbbe} tesszük. Az első
helyre letesszük a hat trapéz adatot, a $0$-ás indexet, és egy kis részt
kihagyunk. Majd letesszük ugyanannak a trapéznak az adatait, az $1$-es indexet,
és szintén egy kis üres helyet kihagyunk. Majd ugyanígy járunk el a $2$-es és a
$3$-as indexekkel is. Teljesen hasonló helyezhetjük el a tömbbe a második
trapézt. A kis kihagyásokra azért van szükség, mert a GLES2 elvárja, hogy négy
\func{float} méretére legyenek az adatok igazítva. Nekünk pedig effektív hét
\func{float} típusú értékünk van.

Most nézzük meg részletesebben, hogy mi is történik az adatokkal a vertex
shader-ben. Minden vertex egyrészt meghatározza a végső pontját, ami így
kijelöli, hogy mely raszterpontokra kell majd lefusson a fragment shader-ből
előállított program. Másrészt néhány olyan adatot is kiszámol, aminek az
interpolációja meghatározó lesz a fragment shader-ek számára.

A vertexek gyakran nem esnek pontosan egy raszterpont közepére. Vagyis
lehetséges, hogy a háromszög szélei és csúcsai belógnak egy raszterbe, de a
raszter közepe már nem része a háromszögnek. Így viszont pont az élsimítás
lehetősége veszik el, hiszen ebben az esetben ezekre a pontokra nem fut le a
fragment program. Ezért a vertexek a kapott adatokból kiszámolják egy fél
raszterpont méretével nagyobb háromszög szerinti pontjukat. Magyarán egy
kicsivel meghízik az eredeti háromszög, így az összes érintett raszterpont
bekerül. Lehetséges, hogy olyanok is bekerülnek, amiket az eredeti háromszög
nem érint, ezek viszont úgyis nulla intenzitásúak lesznek.

Miután meghatározta a vertex program az aktuális vertex kibővitett pontját,
utána még a fragment shader-nek szükséges értékeket is kiszámol, illetve
beállít. Az értékeket a shader-ek között megosztást biztosító változókba
(\inenglish{varyings}) tesz. Ilyen érték a vertex új koordinátája. Ez
kulcsfontosságú beállítás, mert ez az értékpár lesz végül interpolálva, és
innen tudja majd az egyes raszterpontokra lefutó fragment program, hogy a
háromszögön belül hova tartozik. De meghatározza még a két trapézszár
meredekségét és valódi alsó, felső alapvonalának értékét is.

Egy fontos részről még nem volt szó a vertex shader kódjával kapcsolatban. A
renderelést mindig a $(-1, -1, 0)$ és $(1, 1, 0)$ pontok által meghatározott
négyzetben hajtjuk végre. Ezért a koordinátákat ebbe a síkba kell
normalizálnunk. Vagyis ezt a négyzetet mint \emph{láthatósági ablakot}
(\inenglish{view port}) kell kezelnünk. Ehhez \func{uniform} típusú egyedi
változó formájában át kell adnunk a vertex shader-nek a vászon méretét. Ezzel a
mérettel pedig már le tudjuk normalizálni a vertex koordinátákat. Ebből
fakadóan az is következik, hogyha olyan háromszögek jönnének létre, amik nem
esnek a láthatósági ablakba, akkor azokat nem is fogja kirenderelni a GPU. A mi
esetünkben az ilyen trapézokat már CPU oldalon leválogattuk, és eldobtuk.

A vertex programok után az érintett fragmentekre fut le a fragment shader-ből
előálló program. Az alakzat képét azonban nem direkt az eredménytömbbe
rendereljük, hanem még a rajzolást kiváltó hívás előtt bekötünk egy alakzatot
befoglaló méretű (\inenglish{bounding box}) \func{GL\_ALPHA} típusú textúrát.
Ebbe a textúrába várjuk az alakzat képét. Ez a textúra egy egycsatornás
átláthatóságot leíró típus. Ahol a textúra pontjai a $0$, teljesen átlátszó
értéktől a $255$, teljesen átfedő értékig vehetnek fel értékeket. Jellemzően az
alakzat belsejében ez $255$, azaz teljesen elfedő, míg a szélein az
élsimításnak megfelelően részben áteresztő lesz. Valamint a befoglaló
téglalapnak az alakzathoz nem tartozó pontjai pedig teljesen áteresztőek ($0$
értékűek).

A fragment shader tíz, részben interpolált változó értéket kap. Ebből két érték
interpolálódik. A \emph{kifelé kerekített}\footnote{A kifelé kerekítés itt azt
jelenti, hogy a kerekített koordináták vagy pont a sarkokra, vagy az alakzaton
kívülre esnek.} két sarokkoordináta távolsága a bal alsó sarokhoz képest. Így
az egyes fragmentek úgy kapják meg ezt a két értéket, hogy azoknak az
egész-része meghatározza a fragment helyét az alakzathoz képest. Ami első
körben két esetet jelent. Az egyik, hogy a fragment az alakzatban van, tehát
teljes intenzitással ki kell gyújtani. Vagy a másik, hogy az alakzat szélén
helyezkedik el, tehát részben áteresztő lesz. A maradék nyolc érték közül kettő
a bal és jobb meredekség értéke, három-három érték pedig trapézzal kapcsolatos
értékek: az alsó alap hossza, a trapéz magassága, a fragmenten belüli alsó bal
és jobb $x$ értékek törtrészei, valamint a hasonló alsó és felső $y$ értékek
tört részei. Minden fragmentre kiszámoljuk a helyét az alakzaton belül, majd ez
alapján meghatározzuk, hogy a lefedettség $y$ szerint mettől meddig tart.
Ezután az élsimítás értékének (pl. a maximális $16$) megfelelő részre osztjuk
horizontálisan a fragmentet. Ha a fragment aljától a tetejéig tart a
lefedetség, akkor az összes ($16$ darab) osztott részt érintjük, és az azokhoz
tartozó részeket összegezzük. Különben csak a lefedésben érintett sávokat
összegezzük. A sávok esetében pedig az átadott meredekségeknek és a trapéz
sarokpontjainak köszönhetően el tudjuk dönteni, hogy a sáv teljesen fedett az
$x$ értékek szerint, vagy csak egy része. Természetesen a belső pontok
gyakoribbak lesznek, így a fragment intenzitását a shader elején az $1.0$
maximális értékre\footnote{Az \emph{alpha} csatorna mérete \emph{egy bájt},
ugyanakkor a shader-ben ez egy $0.0$ és $1.0$ közti \func{float} típusú
lebegőpontos érték.} állítjuk. Majd eldöntjük, hogy a fragmnet belső pont-e, és
csak akkor számoljuk ki a fent említett iterációval az $1.0$-nál kisebb
\emph{alpha} értéket, ha szélső fragmentről van szó.

Így az alakzat képét egy alpha textúra tartalmazza. Ezek után egy újabb vertex
és fragment shader-párból álló programmal az alpha textúra segítségével egy
\emph{színezett textúrába} (\inenglish{color texture}) a megfelelő szín szerint
az alakzat színezett képét másoljuk. Ez továbbra is az alakzatot befoglaló
téglalap méretű textúra lesz. Ezt lefedő téglalappal (két háromszög)
renderelünk egy nagyon egyszerű vertex és fragment shader segítségével. A
vertex shader csak a téglalap sarkai szerint beállítja a négy vertex végső
pontját, illetve az ezekhez tartozó alpha textúra megfelelő sarokpontjai. A
fragment shader pedig megkapja egyedi változóban az alpha textúra azonosítóját
és a kitöltés \func{RGBA} színét, valamint interpolált értékként a fragmentnek
megfelelő alpha textúrabeli koordinátát. A koordináta segítségével az alpha
textúrából a fragmenthez tartozó kitöltési intenzitást lekéri, és a szín érték
végső alpha (áttetszőségi) értékét felszorozza. Ezzel az alakzat színhelyes
képét minden fragmentre megkapjuk.

Ezek után egy harmadik lépésben az előző vertex és fragment shader nagyon
hasonlító módon a színes textúrát az eredmény tömb megfelelő helyére
felmásoljuk. Ezzel gyakorlatilag a dolgozatunkban kitűzött célt elértük.

Még röviden érdemes átgondolni, hogy a jelenleg nem támogatott, de jövőbeli
\emph{gradiens színezés}, vagy \emph{kivágás} (\inenglish{clipping}) az alpha
textúrának köszönhetően a folyamatba beépíthető. Hiszen az alpha textúrát akár
kivágási ablaknak is használhatjuk. Tehát egy gradiens textúrát is kivághatunk
az alakzat kpével, ezzel az alakzat gradiens színezett képét megkapva.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Használat és eredmények                                        %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter{Használat és eredmények}
    %\addcontentsline{toc}{section}{Használat és eredmények}

Nézzük meg röviden, hogy hogyan lehet használni a Gepardot. Illetve
hasonlítsuk össze az elért eredményeket néhány ismertebb Canvas 2D Context
szabványt támogató renderelő program eredményével.

    \section{Használat}

Arról volt szó, hogy a forráskód C++ nyelven írt. Ennek megfelelően a
projekt is C++ alapú. A teljes projekt több részt tartalmaz. Az első és
legfontosabb a Gepard API-hoz tartozó \emph{függvénykönyvtár}. További
részek: a belső osztályok és struktúrák \emph{egységtesztjei}
(\inenglish{unit tests}), példakódok és valódi, a Gepard-ot használó programok.
A projektet a \emph{lefordítás} (\inenglish{building}) szempontjából a
\func{CMake} rendszer fogja össze. Ez a fent felsorolt részek
célegységként (\inenglish{target}) való lefordítását írja le.

A Gepard használatát az \emph{Ubuntu 18.04 (64 bit)} operációs rendszeren
mutatjuk be. A célegységeket a \emph{gcc} (7.3.0) C++ fordító programmal készítjük el.
A Háttér (\ref{Háttér}) részben bemutatott aprócska HTML -- Canvas
programrészletet használjuk fel.

Tehát a Gepard függvénykönyvtár előállítása az említett operációs
rendszeren a következő parancsokkal történik:
{\small
  \begin{itemize} \renewcommand\labelitemi{\texttt{\$}}
    \item \begin{verbatim}cmake -H. -Bbuild -DBACKEND=GLES2 \end{verbatim}
    \item \begin{verbatim}make -C build gepard\end{verbatim}
  \end{itemize}
}

Természetesen a Gepardnak is vannak függőségei. A fordításhoz mindenképpen
érdemes előre telepíteni a következő csomagokat:
{\small
  \begin{itemize} \renewcommand\labelitemi{\texttt{\$}}
    \item \begin{verbatim}apt install build-essential cmake\end{verbatim}
    \item \begin{verbatim}apt install libegl1-mesa-dev libgles2-mesa-dev freeglut3-dev\end{verbatim}
  \end{itemize}
}

Ezután a Háttér részben bemutatott programrészletünk a következőképpen módosul:

  \minipage{0.8\textwidth}
    \begin{lstlisting}[language=C++, autogobble=true]
      #include "gepard.h"
      #include "gepard-xsurface.h"

      void main() {
          gepard::XSurface surface(640 /*width*/, 480 /*height*/);
          gepard::Gepard ctx(&surface);
          ctx.fillStyle = "#b4e256";
          ctx.strokeStyle = "#25385e";
          ctx.beginPath();
          ctx.moveTo(5, 0);
          ctx.lineTo(6, 9);
          ctx.lineTo(0, 3);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
      }
    \end{lstlisting}
  \endminipage

  \begin{figure}[!htb]
    \centering
    \includegraphics[width=.95\textwidth]{img/built/erdely}
    \caption{\label{erdely} Hogy használjuk a Gepardot.}
  \end{figure}

  \begin{description}[noitemsep]
    \item[Kulcsszavak] Gepard kontext, libgepard.
    \item[Becsült oldalszám] 4.
  \end{description}

    \section{Eredmények}
    \label{Eredmények}

  Itt a lefedettséget, illetve néhány ismert rajzolóval való minőségi
összehasonlítást fogom bemutatni.

  \begin{description}[noitemsep]
    \item[Kulcsszavak] Blink, Gecko.
    \item[Becsült oldalszám] 4.
  \end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Összefoglalás                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter{Összefoglalás}
    \addcontentsline{toc}{section}{Összefoglalás}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Irodalomjegyzék                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \nocite{Foley:1990:CGP:83821}
    \bibliography{bib/cites}{}
    \bibliographystyle{bib/huplain}
    \addtocontents{toc}{\ }
    \addcontentsline{toc}{section}{Irodalomjegyzék}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Mellékletek                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter*{Mellékletek}
    \addcontentsline{toc}{section}{Mellékletek}


  \begin{figure}[!htb]
  \begin{center}
    \includegraphics[scale=0.5]{img/built/tiger}
  \end{center}
    \caption{\label{tiger} A tiger.svg}
  \end{figure}

  \begin{figure}[!htb]
  \begin{center}
    \includegraphics[scale=0.8]{img/built/dataflow_eps}
  \end{center}
    \caption{\label{dataflow} A rajzolás folyamatai}
  \end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Nyilatkozat                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter*{Nyilatkozat}
    %Egy üres sort adunk a tartalomjegyzékhez:
    \addcontentsline{toc}{section}{Nyilatkozat}
    %\hspace{\parindent}

    % A nyilatkozat szövege más titkos és nem titkos dolgozatok esetében.
    % Csak az egyik típusú nyilatkozatnak kell a dolgozatban szerepelni
    % A pontok helyére az adatok értelemszerűen behelyettesítendők és
    % a szakdolgozat /diplomamunka szó megfelelően kiválasztandó.


    % A nyilatkozat szövege TITKOSNAK NEM MINŐSÍTETT dolgozatban a következő:
    % A pontokkal jelölt szövegrészek értelemszerűen a szövegszerkesztőben és
    % nem kézzel helyettesítendők:

    \noindent

Alulírott \makebox[4cm]{\dotfill} szakos hallgató, kijelentem, hogy a dolgozatomat a Szegedi Tudományegyetem, Informatikai Tanszékcsoport \makebox[4cm]{\dotfill} Tanszékén készítettem, \makebox[4cm]{\dotfill} diploma megszerzése érdekében.

Kijelentem, hogy a dolgozatot más szakon korábban nem védtem meg, saját munkám eredménye, és csak a hivatkozott forrásokat (szakirodalom, eszközök, stb.) használtam fel.

Tudomásul veszem, hogy szakdolgozatomat / diplomamunkámat a Szegedi Tudományegyetem Informatikai Tanszékcsoport könyvtárában, a helyben olvasható könyvek között helyezik el.

    \vspace*{2cm}

    \begin{tabular}{lc}
    Szeged, \today\
    \hspace{2cm} & \makebox[6cm]{\dotfill} \\
    & aláírás \\
    \end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Köszönetnyilvánítás                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \chapter*{Köszönetnyilvánítás}
    \addcontentsline{toc}{section}{Köszönetnyilvánítás}

Ezúton szeretnék köszönetet mondani \textbf{X. Y-nak} ezért és ezért \ldots


\end{document}
